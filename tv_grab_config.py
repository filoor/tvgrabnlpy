#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# Python 3 compatibility
from __future__ import unicode_literals
# from __future__ import print_function

description_text = """
    SYNOPSIS

    tv_grab_nl_py is a python script that trawls tvgids.nl for TV
    programming information and outputs it in XMLTV-formatted output (see
    http://membled.com/work/apps/xmltv). Users of MythTV
    (http://www.mythtv.org) will appreciate the output generated by this
    grabber, because it fills the category fields, i.e. colors in the EPG,
    and has logos for most channels automagically available. Check the
    website below for screenshots.  The newest version of this script can be
    found here:

         https://github.com/tvgrabbers/tvgrabnlpy/

    USAGE

    Check the web site above and/or run script with --help and start from there

    REQUIREMENTS

    * Python 2.6 or 2.7
    * Connection with the Internet

    QUESTIONS

    Questions (and patches) are welcome at:
    http://www.pwdebruin.net/mailman/listinfo/tv_grab_nl_py_pwdebruin.net
    https://github.com/tvgrabbers/tvgrabnlpy/issues
    https://groups.google.com/forum/#!forum/tvgrabnlpy

    UPGRADE NOTES

    If you were using tv_grab_nl from the XMLTV bundle then enable the
    compat flag or use the --compat command-line option.  Otherwise, the
    xmltvid's are wrong and you will not see any new data in MythTV.

    HISTORY

    tv_grab_nl_py used to be called tv_grab_nl_pdb, created by Paul de Bruin
    and first released on 2003/07/09. At the same time the code base switched
    from using CVS to SVN at Google Code, and as a result the version numbering
    scheme has changed. The lastest official release of tv_grab_nl_pdb is 0.48.
    The first official release of tv_grab_nl_py is 6. In 2012, The codebase
    moved to Git, and the version number was changed once more. The latest
    subversion release of tv_grab_nl_py is r109. The first Git release of
    tv_grab_nl_py is 2012-03-11 12:03.

    As of december 2014/ januari 2015 Version 2.0.0:
      Upgrading argument processing from getopt to argparse.
      Also adding some options and adding to help text.
      Fixing a small bug preventing multiple word details like 'jaar van
        premiere' from being proccessed.
      Adding genre/subgenre translation table and file (tv_grab_nl_py.set).
        Automatically adding new genre/subgenre combinations on every scan.
        Still looking into the way MythTV handles this.
        This contains also other translation tables which mostly get updated on
        every scan and gets created with defaults if not existing.
      Adding titlesplit exception list to tv_grab_nl_py.set. Especially for
        spin-off series like 'NCIS: Los Angeles'.
      Adding optional default options file and creation.  (tv_grab_nl_py.opt)
      Adding optional proccessing of HD attribute.
      Adding session log function (to the configname with .log added)
        the last log is saved to .old (like with .conf, .opt and .set files)
      Adding rtl.nl lookup for the 7 RTL channels. This adds season/episode info
        and lookup further than 4 days in the future, defaulting to 14 days.
        Genre info is missing. Timing and description from rtl.nl is used over
        tvgids.nl
      Adding  teveblad.be lookup, mainly for belgium channels. This adds
        season/episode info and lookup up to 7 days. Dutch channels only
        have prime-time info and the commercial channels are missing.
        Genre info is basic. Timing for the Belgium channels is used over
        tvgids.nl
      Adding tvgids.tv lookup. This adds lookup up to 14 days with decent genre
        info.
      Merged tv_grab_nl_py.opt into tv_grab_nl_py.conf and added several
        translation tables to tv_grab_nl_py.set.
      Moving html proccessing from pure regex filtering to ElementTree
      Reorganised code to be more generic to make adding new sources easer
        and as preparation for a configuration module. Also put the different
        sources in parallel threads.
      Working on more intelligent description proccessing.
      Working in ever more intelligent source merging.
      Working on a configuration module.
      Possibly adding ttvdb.com and tmdb3.com lookup for missing descriptions
        and season/episode info
      Possibly adding more optional (foreign) sources (atlas?)

    CONTRIBUTORS

    Main author: Paul de Bruin (paul at pwdebruin dot net)
    Current maintainer: Freek Dijkstra (software at macfreek dot nl)
    Currently 'december 2014' the latest version of '2012-03-27' adapted by:
    Hika van den Hoven hikavdh at gmail dot com, but also active on the
    mythtv list: mythtv-users at mythtv dot org

    Michel van der Laan made available his extensive collection of
    high-quality logos that is used by this script.

    Several other people have provided feedback and patches:
    Huub Bouma, Michael Heus, Udo van den Heuvel, Han Holl, Hugo van der Kooij,
    Roy van der Kuil, Ian Mcdonald, Dennis van Onselen, Remco Rotteveel, Paul
    Sijben, Willem Vermin, Michel Veerman, Sietse Visser, Mark Wormgoor.

    LICENSE

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import os, re, sys, argparse, traceback, datetime, codecs, pickle, json
import tv_grab_IO, tv_grab_fetch , pytz
try:
    unichr(42)
except NameError:
    unichr = chr    # Python 3

class Configure:

    def __init__(self):
        # Version info as returned by the version function
        self.api_name ='tv_grab_API'
        self.api_major = 1
        self.api_minor = 0
        self.api_patch = 0
        self.api_patchdate = u'20160224'
        self.api_alfa = True
        self.api_beta = True
        try:
           x = self.name
        except AttributeError:
            self.name ='tv_grab_configure.py'
        self.major = self.api_major
        self.minor = self.api_minor
        self.patch = self.api_patch
        self.patchdate = self.api_patchdate
        self.alfa = self.api_alfa
        self.beta = self.api_beta
        self.utc_tz = pytz.utc
        self.output_tz = self.utc_tz
        self.opt_dict = {}
        self.user_agents = [ 'Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1.9) Gecko/20071025 Firefox/2.0.0.9',
               'Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.8.1.19) Gecko/20081216 Ubuntu/8.04 (hardy) Firefox/2.0.0.19',
               'Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko',
               'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.75.14 (KHTML, like Gecko) Version/7.0.3 Safari/7046A194A',
               'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 7.0; InfoPath.3; .NET CLR 3.1.40767; Trident/6.0; en-IN)',
               'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:42.0) Gecko/20100101 Firefox/42.0',
               'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.1 Safari/537.36',
               'Mozilla/5.0 (X11; Linux x86_64; rv:38.0) Gecko/20100101 Firefox/38.0']

        self.write_info_files = False
        self.infofiles = None
        self.log_output = None
        self.httpencoding = 'iso-8859-15'
        self.file_encoding = 'utf-8'
        self.do_clump = False
        self.ttvdb_disabled_groups = (6, 8, 11, 12, 13, 17)
        self.weekdagen = ('zondag', 'maandag', 'dinsdag', 'woensdag', 'donderdag', 'vrijdag', 'zaterdag')
        self.kijkwijzer = {'1': {'code': 'AL','text': 'Voor alle leeftijden',
                        'icon':'http://tvgidsassets.nl/img/kijkwijzer/al_transp.png'},
                        '2': {'code': '6+','text': 'Afgeraden voor kinderen jonger dan 6 jaar',
                        'icon':'http://tvgidsassets.nl/img/kijkwijzer/6_transp.png'},
                        '9': {'code': '9+','text': 'Afgeraden voor kinderen jonger dan 9 jaar',
                        'icon':'http://tvgidsassets.nl/img/kijkwijzer/9_transp.png'},
                        '3': {'code': '12+','text': 'Afgeraden voor kinderen jonger dan 12 jaar',
                        'icon':'http://tvgidsassets.nl/img/kijkwijzer/12_transp.png'},
                        '4': {'code': '16+','text': 'Niet voor personen tot 16 jaar',
                        'icon':'http://tvgidsassets.nl/img/kijkwijzer/16_transp.png'},
                        'g': {'code': 'Geweld','text': 'Geweld',
                        'icon':'http://tvgidsassets.nl/img/kijkwijzer/geweld_transp.png'},
                        'a': {'code': 'Angst','text': 'Angst',
                        'icon':'http://tvgidsassets.nl/img/kijkwijzer/angst_transp.png'},
                        's': {'code': 'Seks','text': 'Seks',
                        'icon':'http://tvgidsassets.nl/img/kijkwijzer/seks_transp.png'},
                        't': {'code': 'Grof','text': 'Grof taalgebruik',
                        'icon':'http://tvgidsassets.nl/img/kijkwijzer/grof_transp.png'},
                        'h': {'code': 'Drugs','text': 'drugs- en/of alcoholmisbruik',
                        'icon':'http://tvgidsassets.nl/img/kijkwijzer/drugs_transp.png'},
                        'd': {'code': 'Discriminatie','text': 'Discriminatie',
                        'icon':'http://tvgidsassets.nl/img/kijkwijzer/discriminatie_transp.png'}}

        self.tvkijkwijzer = {'AL':'1',
                                      '6':'2',
                                      '9':'9',
                                      '12':'3',
                                      '16':'4',
                                      'angst':'a',
                                      'geweld':'g',
                                      'seks':'s',
                                      'taal':'t'}

        self.vrtkijkwijzer = {'6+':'2',
                                      '9+':'9',
                                      '12+':'3',
                                      '16+':'4'}

        self.roletrans = {"regisseur"                         : "director",
                             "regie"                                        : "director",
                             "met"                                            : "actor",
                             "acteurs"                                    : "actor",
                             "acteursnamen_rolverdeling": "actor",
                             "gastacteur"                              : "guest",
                             "scenario"                                  : "writer",
                             "scenario schrijver"              : "writer",
                             "componist"                                : "composer",
                             "presentatie"                            : "presenter",
                             "presentator"                            : "presenter",
                             "verslaggever"                          : "reporter",
                             "commentaar"                              : "commentator",
                             "adapter"                                    : "adapter",
                             "producer"                                  : "producer",
                             "editor"                                      : "editor"}

        self.coutrytrans = {}
        self.notitlesplit = []
        self.groupnameremove = ['kro detectives', 'detectives', 'premiére']
        self.titlerename = {'navy ncis': 'NCIS',
                                        'inspector banks': 'DCI Banks'}

        # Create a category translation dictionary
        # Look in mythtv/themes/blue/ui.xml for all category names
        # The keys are the categories used by tvgids.nl (lowercase please)
        # See the file ~/.xmltv/tv_grab_nl_py.set created after the first run and edit there!
        self.cattrans = { (u'', u'')                                                 : u'Unknown',
                             (u'amusement', u'')                                      : u'Talk',
                             (u'amusement', u'quiz')                              : u'Game',
                             (u'amusement', u'spelshow')                      : u'Game',
                             (u'amusement', u'muziekshow')                  : u'Art/Music',
                             (u'amusement', u'muziekprogramma')        : u'Art/Music',
                             (u'amusement', u'dansprogramma')            : u'Art/Music',
                             (u'amusement', u'cabaret')                        : u'Art/Music',
                             (u'amusement', u'variete')                        : u'Art/Music',
                             (u'amusement', u'sketches')                      : u'Art/Music',
                             (u'amusement', u'stand-up comedy')        : u'Art/Music',
                             (u'amusement', u'stand-up comedy, sketches'): u'Art/Music',
                             (u'amusement', u'erotisch programma')  : u'Adult',
                             (u'amusement', u'komedie')                        : u'Comedy',
                             (u'amusement', u'klusprogramma')            : u'Home/How-to',
                             (u'amusement', u'hobbyprogramma')          : u'Home/How-to',
                             (u'amusement', u'lifestyleprogramma')  : u'Home/How-to',
                             (u'amusement', u'modeprogramma')            : u'Home/How-to',
                             (u'amusement', u'kookprogramma')            : u'Cooking',
                             (u'amusement', u'realityserie')              : u'Reality',
                             (u'documentaire', u'')                                : u'Documentary',
                             (u'educatief', u'')                                      : u'Educational',
                             (u'film', u'')                                                : u'Film',
                             (u'korte film', u'')                                    : u'Film',
                             (u'info', u'')                                                : u'News',
                             (u'info', u'business')                                : u'Bus./financial',
                             (u'info', u'documentary')                          : u'Documentary',
                             (u'info', u'science')                                  : u'Science/Nature',
                             (u'informatief, amusement', u'')            : u'Educational',
                             (u'informatief, amusement', u'kookprogramma'): u'Cooking',
                             (u'informatief, kunst en cultuur', u''): u'Arts/Culture',
                             (u'informatief, wetenschap', u'')          : u'Science/Nature',
                             (u'informatief', u'')                                  : u'Educational',
                             (u'informatief', u'wetenschappelijk programma'): u'Science/Nature',
                             (u'informatief', u'techniek')                  : u'Science/Nature',
                             (u'informatief', u'documentaire')          : u'Documentary',
                             (u'informatief', u'gezondheid')              : u'Health',
                             (u'informatief', u'fitnessprogramma')  : u'Health',
                             (u'informatief', u'gymnastiekprogramma'): u'Health',
                             (u'informatief', u'medisch programma'): u'Health',
                             (u'informatief', u'medisch praatprogramma'): u'Health',
                             (u'informatief', u'docusoap')                  : u'Reality',
                             (u'informatief', u'realityprogramma')  : u'Reality',
                             (u'informatief', u'realityserie')          : u'Reality',
                             (u'informatief', u'praatprogramma')      : u'Talk',
                             (u'informatief', u'jeugdprogramma')      : u'Children',
                             (u'jeugd', u'')                                              : u'Children',
                             (u'kunst/cultuur', u'')                              : u'Arts/Culture',
                             (u'kunst en cultuur', u'')                        : u'Arts/Culture',
                             (u'magazine', u'')                                        : u'Talk',
                             (u'muziek', u'')                                            : u'Art/Music',
                             (u'natuur', u'')                                            : u'Science/Nature',
                             (u'nieuws/actualiteiten', u'')                : u'News',
                             (u'news', u'')                                                : u'News',
                             (u'religieus', u'')                                      : u'Religion',
                             (u'serie/soap', u'')                                    : u'Drama',
                             (u'serie/soap', u'jeugdserie')                : u'Children',
                             (u'serie/soap', u'animatieserie')          : u'Children',
                             (u'serie/soap', u'tekenfilmserie')        : u'Children',
                             (u'serie/soap', u'soap')                            : u'Soap',
                             (u'serie/soap', u'comedyserie')              : u'Comedy',
                             (u'serie/soap', u'komedieserie')            : u'Comedy',
                             (u'serie/soap', u'detectiveserie')        : u'Crime/Mystery',
                             (u'serie/soap', u'misdaadserie')            : u'Crime/Mystery',
                             (u'serie/soap', u'fantasyserie')            : u'Sci-fi/Fantasy',
                             (u'serie/soap', u'sciencefictionserie'): u'Sci-fi/Fantasy',
                             (u'serie/soap', u'actieserie')                : u'Action',
                             (u'sport', u'')                                              : u'Sports',
                             (u'talks', u'')                                              : u'Talk',
                             (u'talkshow', u'')                                        : u'Talk',
                             (u'wetenschap', u'')                                    : u'Science/Nature',
                             (u'overige', u'')                                          : u'Unknown'}

        self.genre_list = []

        # These ara all dicts used in merging the sources
        self.source_cattrans = {}
        self.new_cattrans = {}
        # tvgids.tv subgenre to genre translation table
        self.source_cattrans[1] = {u'euromillions': u'Amusement',
                                 u'erotisch magazine': u'Amusement',
                                 u'reality-reeks': u'Amusement',
                                 u'keno': u'Amusement',
                                 u'loterij': u'Amusement',
                                 u'spektakel': u'Amusement',
                                 u'informatief programma': u'Informatief',
                                 u'reportage': u'Informatief',
                                 u'biografie': u'Informatief',
                                 u'schooltelevisie': u'Informatief',
                                 u'peuterprogramma': u'Jeugd',
                                 u'kleuterprogramma': u'Jeugd',
                                 u'tekenfilm': u'Jeugd',
                                 u'animatiereeks': u'Jeugd',
                                 u'theatershow': u'Kunst en Cultuur',
                                 u'concert': u'Muziek',
                                 u'musical': u'Muziek',
                                 u'weerbericht': u'Nieuws/Actualiteiten',
                                 u'verkeersinfo': u'Nieuws/Actualiteiten',
                                 u'actualiteitenmagazine': u'Nieuws/Actualiteiten',
                                 u'actuele reportage': u'Nieuws/Actualiteiten',
                                 u'praatprogramma over de actualiteit': u'Nieuws/Actualiteiten',
                                 u'voetbal': u'Sport',
                                 u'darts': u'Sport',
                                 u'golf': u'Sport',
                                 u'wielrennen op de weg': u'Sport',
                                 u'baanwielrennen': u'Sport',
                                 u'tennis': u'Sport',
                                 u'veldrijden': u'Sport',
                                 u'volleybal': u'Sport',
                                 u'motorcross': u'Sport',
                                 u'religieuze uitzending': u'Religieus',
                                 u'docusoap': u'Informatief',
                                 u'sitcom': u'Serie/Soap'}

        self.new_cattrans[1] = []

        # teveblad.be genre translation table
        self.source_cattrans[3] = {u'amusement'           : (u'Amusement', u''),
                                 u'documentaire'      : (u'Informatief', u'Documentaire'),
                                 u'film'                      : (u'Film', u''),
                                 u'kinderen'              : (u'Jeugd', u''),
                                 u'kunst & cultuur': (u'Kunst en Cultuur', u''),
                                 u'magazine'              : (u'Magazine', u''),
                                 u'muziek'                  : (u'Muziek', u''),
                                 u'nieuws'                  : (u'Nieuws/Actualiteiten', u''),
                                 u'reality'                : (u'informatief', u'realityprogramma'),
                                 u'serie'                    : (u'Serie/Soap', u''),
                                 u'sport'                    : (u'Sport', u''),
                                 u'andere'                  : (u'Overige', u'')}

        self.new_cattrans[3] = {}

        # npo.nl genre translation table
        self.source_cattrans[4] = {(u'nieuws-actualiteiten', ): (u'nieuws/actualiteiten', u''),
                                     (u'amusement', ): (u'amusement', u''),
                                     (u'amusement', u'komisch', ): (u'amusement', u'komedie'),
                                     (u'amusement', u'spel-quiz', ): (u'amusement', u'quiz'),
                                     (u'informatief', ): (u'informatief', u''),
                                     (u'informatief', u'nieuws-actualiteiten', ): (u'nieuws/actualiteiten', u''),
                                     (u'informatief', u'kunst-cultuur', ): (u'informatief', u'kunst/cultuur'),
                                     (u'informatief', u'gezondheid-opvoeding', ): (u'informatief', u'gezondheid'),
                                     (u'informatief', u'consumenten-informatie', ): (u'informatief', u'consument'),
                                     (u'informatief', u'spel-quiz', ): (u'informatief', u'quiz'),
                                     (u'informatief', u'koken-eten', ): (u'informatief', u'kookprogramma'),
                                     (u'informatief', u'natuur', ): (u'natuur', u''),
                                     (u'informatief', u'religieus' ): (u'religieus', u''),
                                     (u'religieus', ): (u'religieus', u''),
                                     (u'jeugd', ): (u'jeugd', u''),
                                     (u'jeugd', u'animatie', ): (u'jeugd', u'animatieserie'),
                                     (u'jeugd', u'spel-quiz', ): (u'jeugd', u'quiz'),
                                     (u'documentaire', ): (u'documentaire', u''),
                                     (u'documentaire', u'kunst-cultuur', ): (u'documentaire', u'kunst/cultuur'),
                                     (u'sport', ): (u'sport', u''),
                                     (u'sport', u'sport-informatie', ): (u'sport', u'journaal'),
                                     (u'animatie', ): (u'serie/soap', u'animatieserie'),
                                     (u'natuur', ): (u'natuur', u''),
                                     (u'muziek', ): (u'muziek', u''),
                                     (u'muziek', u'muziek-populair', ): (u'muziek', u'populair'),
                                     (u'muziek', u'muziek-klassiek', ): (u'muziek', u'klassiek'),
                                     (u'film', ): (u'film', u''),
                                     (u'film', u'animatie', ): (u'film', u'animatieserie'),
                                     (u'film', u'spanning', ): (u'film', u'thriller'),
                                     (u'wetenschap', ): (u'wetenschap', u''),
                                     (u'drama', ): (u'serie/soap', u'drama'),
                                     (u'reizen', ): (u'reizen', u''),
                                     (u'serie', ): (u'serie/soap', u''),
                                     (u'serie', u'soap-serie', ): (u'serie/soap', u'soap')}
                                     #~ u'14': (u'serie/soap', u''),
                                     #~ u'15': (u'overige', u''),
                                     #~ u'18': (u'serie/soap', u'misdaadserie'),
                                     #~ u'19': (u'kunst/cultuur', u''),
                                     #~ u'20': (u'amusement', u'erotisch programma'),
                                     #~ u'23': (u'amusement', u'komedie'),
                                     #~ u'26': (u'educatief', u''),
                                     #~ u'27': (u'informatief', u'fitnessprogramma'),
                                     #~ u'29': (u'jeugd', u'6-12'),
                                     #~ u'30': (u'maatschappij', u''),
                                     #~ u'32': (u'jeugd', u'2-5'),
                                     #~ u'34': (u'muziek', u'klassiek'),
                                     #~ u'77': (u'gezondheid-opvoeding', u''),
                                     #~ u'79': (u'komisch', u''),
                                     #~ u'80': (u'spanning', u''),
                                     #~ u'81': (u'consumenten-informatie', u''),
                                     #~ u'82': (u'wonen-tuin', u''),
                                     #~ u'83': (u'muziek-populair', u''),
                                     #~ u'84': (u'spel-quiz', u''),
                                     #~ u'85': (u'cabaret', u''),
                                     #~ u'86': (u'sport-informatie', u''),
                                     #~ u'87': (u'muziek-klassiek', u''),
                                     #~ u'88': (u'koken-eten', u''),
                                     #~ u'89': (u'geschiedenis', u''),
                                     #~ u'90': (u'sport-wedstrijd', u''),
                                     #~ u'91': (u'soap-serie', u'')}

        self.new_cattrans[4] = {}
        self.npo_fill = u'Programmainfo en Reclame'

        # horizon.tv genre translation table
        self.source_cattrans[5] ={(u'13946319', ): (u'nieuws/actualiteiten',u''),
                                     (u'13946319', u'13946323'): (u'informatief', u'Documentaire'),
                                     (u'13946319', u'13946324'): (u'informatief', u'Discussie'),
                                     (u'13946336', ): (u'amusement',u''),
                                     (u'13946336', u'13946338'): (u'kunst en cultuur', u'Variété'),
                                     (u'13946336', u'13946340'): (u'talkshow', u''),
                                     (u'13946352', ): (u'sport',u''),
                                     (u'13946369', ): (u'jeugd', u''),
                                     (u'13946386', ): (u'muziek', u''),
                                     (u'13946404', ): (u'kunst en cultuur', u''),
                                     (u'13946404', u'13946407'): (u'religieus', u''),
                                     (u'13946455', ): (u'informatief', u''),
                                     (u'13946420', ): (u'informatief', u''),
                                     (u'13946438', ): (u'informatief', u''),
                                     (u'13946472', ): (u'informatief', u''),
                                     (u'13948023', ): (u'serie/soap', u''),
                                     (u'13948023', u'13948024'): (u'serie/soap', u'thriller'),
                                     (u'13948023', u'13948025'): (u'serie/soap', u'actieserie'),
                                     (u'13948023', u'13948026'): (u'serie/soap', u'sciencefictionserie'),
                                     (u'13948023', u'13948027'): (u'serie/soap', u'comedyserie'),
                                     (u'13948023', u'13948028'): (u'serie/soap', u'melodrama'),
                                     (u'13948023', u'13948031'): (u'serie/soap', u'historisch'),
                                     (u'13948023', u'13948032'): (u'serie/soap', u'waar gebeurt'),
                                     (u'13948023', u'13948033'): (u'serie/soap', u'detectiveserie')}
        self.new_cattrans[5] = {}

        # humo.be genre translation table
        self.source_cattrans[6] = {u'nieuws'       : (u'Nieuws/Actualiteiten', u''),
                                 u'current-affairs': (u'Nieuws/Actualiteiten', u'Actualiteiten'),
                                 u'magazine'              : (u'Magazine', u''),
                                 u'reportage'            : (u'Informatief', u'Reportage'),
                                 u'documentaire'      : (u'Informatief', u'Documentaire'),
                                 u'talkshow'              : (u'Talkshow', u''),
                                 u'reality'                : (u'Amusement', u'Realityserie'),
                                 u'kinderen'              : (u'jeugd', u''),
                                 u'animated-cartoon': (u'serie/soap', u'animatieserie'),
                                 u'serie'                    : (u'Serie/Soap', u''),
                                 u'miniserie'            : (u'Serie/Soap', u''),
                                 u'soap'                      : (u'Serie/Soap', u'Soap'),
                                 u'film'                      : (u'Film', u''),
                                 u'tv-film'                : (u'Film', u'TV Film'),
                                 u'movie-short'        : (u'Film', u'Korte Film'),
                                 u'quiz'                      : (u'Amusement', u'Quiz'),
                                 u'spel'                      : (u'amusement', u'spelshow'),
                                 u'amusement'            : (u'Amusement', u''),
                                 u'religion'              : (u'Religieus', u''),
                                 u'muziek'                  : (u'Muziek', u''),
                                 u'kunst-cultuur'    : (u'kunst en cultuur', u''),
                                 u'sports-football': (u'Sports', u'Voetbal'),
                                 u'sports-cycling'  : (u'Sport', u'Wielrennen'),
                                 u'sports-formula-1-racing'  : (u'Sport', u'Formule-1'),
                                 u'sports-tennis'    : (u'Sport', u'Tennis'),
                                 u'sport'                    : (u'Sport', u''),
                                 u'andere'                  : (u'Overige', u'')}

        self.new_cattrans[6] = {}

        # vpro.nl genre translation table
        self.source_cattrans[7] ={(u'g3011', ): (u'jeugd', u''),
                                     (u'g3012', ): (u'film', u''),
                                     (u'g3013', ): (u'serie/soap', u''),
                                     (u'g3014', ): (u'sport', u''),
                                     (u'g3015', ): (u'muziek', u''),
                                     (u'g3016', ): (u'amusement', u''),
                                     (u'g3017', ): (u'informatief', u''),
                                     (u'g301721', ): (u'Nieuws/Actualiteiten', u''),
                                     (u'g3017', u'g301721'): (u'Nieuws/Actualiteiten', u''),
                                     (u'g301724', ): (u'kunst/cultuur', u''),
                                     (u'g3017', u'g301724'): (u'informatief', u'kunst/cultuur'),
                                     (u'g301725'): (u'natuur', u''),
                                     (u'g3017', u'g301725', ): (u'natuur', u''),
                                     (u'g301726', ): (u'religieus', u''),
                                     (u'g3017', u'g301726' ): (u'religieus', u''),
                                     (u'g301727', ): (u'informatief, wetenschap', u''),
                                     (u'g3017', u'g301727',): (u'informatief, wetenschap', u''),
                                     (u'g3018', ): (u'informatief', u'Documentaire')}
        self.new_cattrans[7] = {}

        # nieuwsblad.be genre translation table
        self.source_cattrans[8] ={}
        self.new_cattrans[8] = {}

        # primo.eu genre translation table
        self.source_cattrans[9] ={u'actua': (u'nieuws/actualiteiten', u'actua'),
                                     u'amusement': (u'amusement', u''),
                                     u'documentaire': (u'documentaire', u''),
                                     u'film': (u'film', u''),
                                     u'kortfilm': (u'film', u''),
                                     u'magazine': (u'magazine', u''),
                                     u'muziek': (u'muziek', u''),
                                     u'nieuws': (u'nieuws/actualiteiten', u'nieuws'),
                                     u'reality-tv': (u'amusement', u'realityprogramma'),
                                     u'religie': (u'religieus', u''),
                                     u'reportage': (u'nieuws/actualiteiten', u'reportage'),
                                     u'serie': (u'serie/soap', u''),
                                     u'spel': (u'amusement', u'spelshow'),
                                     u'sport': (u'sport', u''),
                                     u'talkshow': (u'amusement', u'talkshow'),
                                     u'varia': (u'informatief', u'varia'),
                                     u'zwart/wit film': (u'film', u''),
                                     (u'serie', u'actiereeks'): (u'serie/soap', u'actieserie'),
                                     (u'serie', u'advocatenreeks'): (u'serie/soap', u'advocatenserie'),
                                     (u'serie', u'avonturenreeks'): (u'serie/soap', u'avonturenserie'),
                                     (u'serie', u'detectivereeks'): (u'serie/soap', u'detectiveserie'),
                                     (u'serie', u'dramareeks'): (u'serie/soap', u'dramaserie'),
                                     (u'serie', u'fictiereeks'): (u'serie/soap', u'fictieserie'),
                                     (u'serie', u'jeugdreeks'): (u'jeugd', u'serie'),
                                     (u'serie', u'komische reeks'): (u'serie/soap', u'comedyserie'),
                                     (u'serie', u'minireeks'): (u'serie/soap', u'miniserie'),
                                     (u'serie', u'misdaadreeks'): (u'serie/soap', u'misdaadserie'),
                                     (u'serie', u'romantische reeks'): (u'serie/soap', u'romantische serie'),
                                     (u'serie', u'soapreeks'): (u'serie/soap', u'soap'),
                                     (u'serie', u'thrillerreeks'): (u'serie/soap', u'thrillerserie'),
                                     (u'serie', u'tragikomische reeks'): (u'serie/soap', u'tragikomische serie'),
                                     (u'serie', u'ziekenhuisreeks'): (u'serie/soap', u'ziekenhuisserie')}
        self.new_cattrans[9] = {}

        #vrt.be genre translation table
        self.source_cattrans[10] ={(u'1',): (u'film', u''),
                                                (u'2',): (u'nieuws/actualiteiten', u''),
                                                (u'3',): (u'amusement', u''),
                                                (u'3', u'1'): (u'amusement', u'spelshow'),
                                                (u'4',): (u'sport', u''),
                                                (u'5',): (u'jeugd', u''),
                                                (u'6',): (u'muziek', u''),
                                                (u'7',): (u'kunst en cultuur', u''),
                                                (u'7', u'3'): (u'religieus', u''),
                                                (u'8',): (u'documentaire', u''),
                                                (u'8', u'2'): (u'informatief', u'economie'),
                                                (u'9',): (u'informatief', u''),
                                                (u'10',): (u'informatief', u''),
                                                (u'13', ): (u'serie/soap', u''),
                                                (u'13', u'1'): (u'serie/soap', u''),
                                                (u'13', u'2'): (u'serie/soap', u'detectiveserie'),
                                                (u'13', u'3'): (u'serie/soap', u'actieserie'),
                                                (u'13', u'4'): (u'serie/soap', u'sciencefictionserie'),
                                                (u'13', u'5'): (u'serie/soap', u'komedieserie'),
                                                (u'13', u'6'): (u'serie/soap', u'soap'),
                                                (u'13', u'8'): (u'serie/soap', u'animatieserie'),
                                                (u'14',): (u'informatief', u''),
                                                (u'14', u'1'): (u'informatief', u'realityprogramma'),
                                                (u'14', u'3'): (u'informatief', u'docusoap')}
        self.new_cattrans[10] = {}

        # The following two list get replaced by their sourcematching counterparts
        # Program group names to exclude from a primesource if the counterpart contains details
        self.groupslot_names = ("ochtend- en dagprogramma's", "ochtend - en dagprogramma's",
                                                "nachtprogramma's", "nachtprogrammering", "kinderprogramma's",
                                                "kinder-tv", "kindertijd", "pause", "geen programmagegevens beschikbaar.")

        self.combined_channels = {u'5-24443943013': [u'0-300'],
                                                     u'5-24443943080': [u'0-301', u'1-cbeebies'],
                                                     u'1-veronica': [u'0-34', u'0-311'],
                                                     u'1-ketnet-canvas-2': [u'8-ketnet', u'8-eenplus']}

        #Channel group names as used in tvgids.tv
        self.group_names = {1: 'Nederlandse kanalen',
                                          2: 'Vlaamse kanalen',
                                          3: 'Engelse kanalen',
                                          4: 'Duitse kanalen',
                                          5: 'Franse kanalen',
                                          6: 'Nederlands Regionaal',
                                          7: 'Overige Nederlands kanalen',
                                          8: 'Vlaams Regionaal',
                                          9: 'Overige Vlaamse kanalen ',
                                         10: 'Internationale kanalen',
                                         11: 'Nederlandse Radio',
                                         12: 'Vlaamse Radio',
                                         13: 'Overige Radio',
                                         99: 'Overig kanalen',
                                         -1: 'Alleen geselecteerde kanalen'}

        self.group_order = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,99]

        self.opt_dict['home_dir'] = ''
        if 'HOME' in os.environ:
            self.opt_dict['home_dir'] = os.environ['HOME']
        elif 'HOMEPATH' in os.environ:
            self.opt_dict['home_dir'] = os.environ['HOMEPATH']
        if os.name == 'nt' and 'USERPROFILE' in os.environ:
            self.opt_dict['home_dir'] = os.environ['USERPROFILE']

        self.opt_dict['xmltv_dir'] = u'%s/.xmltv' % self.opt_dict['home_dir']
        self.opt_dict['config_file'] = u'%s/%s.conf' % (self.opt_dict['xmltv_dir'], self.name)
        self.opt_dict['log_file'] = u'%s/%s.log' % (self.opt_dict['xmltv_dir'], self.name)
        self.opt_dict['settings_file'] = u'%s/%s.set' % (self.opt_dict['xmltv_dir'], self.name)
        self.opt_dict['cache_file'] = u'%s/program_cache' % self.opt_dict['xmltv_dir']
        self.program_cache = None
        self.clean_cache = True
        self.clear_cache = False

        self.opt_dict['language'] = 'en'
        self.opt_dict['nice_time'] = [1, 2]
        self.opt_dict['graphic_frontend'] = False
        self.opt_dict['log_level'] = 175
        self.opt_dict['match_log_level'] = 11
        self.opt_dict['mail_log'] = False
        self.opt_dict['mailserver'] = 'localhost'
        self.opt_dict['mailport'] = 25
        self.opt_dict['mail_log_address'] = 'postmaster'
        self.opt_dict['mail_info_address'] = None
        self.opt_dict['output_file'] = None
        self.opt_dict['global_timeout'] = 10
        self.opt_dict['max_simultaneous_fetches'] = 5
        self.opt_dict['group_active_channels'] = False
        self.opt_dict['always_use_json'] = True
        self.opt_dict['quiet'] = False
        self.opt_dict['fast'] = False
        self.opt_dict['offset'] = 0
        self.opt_dict['days'] = 14
        self.opt_dict['slowdays'] = None
        self.opt_dict['disable_source'] = []
        self.opt_dict['disable_detail_source'] = []
        self.opt_dict['disable_ttvdb'] = False
        self.opt_dict['compat'] = False
        self.opt_dict['legacy_xmltvids'] = False
        self.opt_dict['max_overlap'] = 10
        self.opt_dict['overlap_strategy'] = 'average'
        self.opt_dict['logos'] = True
        self.opt_dict['desc_length'] = 475
        self.opt_dict['cattrans'] = True
        self.opt_dict['mark_hd'] = False
        self.opt_dict['use_utc'] = False
        self.opt_dict['use_split_episodes'] = True
        self.opt_dict['kijkwijzerstijl'] = 'short'

        self.texts = {}
        self.logging = None
        self.threads = []
        self.queues = {}
        self.logging = tv_grab_IO.Logging(self)
        self.IO_func = tv_grab_IO.Functions(self)
        self.fetch_func = tv_grab_fetch.Functions(self)
        self.xml_output = tv_grab_IO.XMLoutput(self)
        self.sources = {0: 'tvgids.nl', 1: 'tvgids.tv', 2: 'rtl.nl', 3: 'teveblad.be', 4: 'npo.nl',
                                  5: 'horizon.tv', 6: 'humo.be', 7: 'vpro.nl', 8: 'nieuwsblad.be', 9:'primo.eu',
                                  10: 'vrt.be', 11: 'virtual', 12: 'oorboekje.nl'}
        self.source_order = [7, 0, 1, 5, 9, 6, 8, 2, 4, 10, 11, 12]
        self.sourceid_order = [0, 9, 1, 2, 4, 7, 5, 6, 8, 10, 11, 12]
        self.source_count = len(self.sources)
        self.detail_sources = (0, 9, 1)
        self.prime_source_order = (2, 4, 7, 0, 5, 1, 9, 6, 8, 10, 11, 12)
        self.channelsource = {}
        self.ttvdb = None

        self.queues['log'] = self.logging.log_queue
        self.queues['source'] = {}
        self.channels = {}
        self.chan_count = 0

        self.lang = 'en'
        self.texts = None
        self.load_text(self.lang)
        self.configversion = None
        self.__CONFIG_SECTIONS__ = { 1: u'Configuration',
                                                            2: u'tvgids.nl Channels',
                                                            3: u'Channels'}


        self.__DEFAULT_SECTIONS__ = {1: u'genre conversion table',
                                                             2: u'no title split list',
                                                             3: u'remove groupname list',
                                                             4: u'rename title list',
                                                             5: u'teveblad.be genres',
                                                             6: u'tvgids.tv genres',
                                                             7: u'role translation',
                                                             8: u'npo.nl genres',
                                                             9: u'horizon.tv genres',
                                                             10: u'humo.be genres',
                                                             11: u'vpro.nl genres',
                                                             13: u'primo.eu genres',
                                                             14: u'vrt.be genres'}

    # end Init()

    def version(self, as_string = False, API = False):
        """
        return tuple or string with version info
        """
        if API:
            if as_string and self.alfa:
                return u'%s (Version: %s.%s.%s-p%s-alpha)' % (self.api_name, self.api_major, self.api_minor, '{:0>2}'.format(self.api_patch), self.api_patchdate)

            if as_string and self.api_beta:
                return u'%s (Version: %s.%s.%s-p%s-beta)' % (self.api_name, self.api_major, self.api_minor, '{:0>2}'.format(self.api_patch), self.api_patchdate)

            if as_string and not self.api_beta:
                return u'%s (Version: %s.%s.%s-p%s)' % (self.api_name, self.api_major, self.api_minor, '{:0>2}'.format(self.api_patch), self.api_patchdate)

            else:
                return (self.api_name, self.api_major, self.api_minor, self.api_patch, self.api_patchdate, self.api_beta, self.api_alfa)

        else:
            if as_string and self.alfa:
                return u'%s (Version: %s.%s.%s-p%s-alpha)' % (self.name, self.major, self.minor, '{:0>2}'.format(self.patch), self.patchdate)

            if as_string and self.beta:
                return u'%s (Version: %s.%s.%s-p%s-beta)' % (self.name, self.major, self.minor, '{:0>2}'.format(self.patch), self.patchdate)

            if as_string and not self.beta:
                return u'%s (Version: %s.%s.%s-p%s)' % (self.name, self.major, self.minor, '{:0>2}'.format(self.patch), self.patchdate)

            else:
                return (self.name, self.major, self.minor, self.patch, self.patchdate, self.beta, self.alfa)

    # end version()

    def log(self, message, log_level = 1, log_target = 3):
        # If logging not (jet) available, make sure important messages go to the screen
        if (self.logging.log_output == None) and (log_level < 2) and (log_target & 1):
            if isinstance(message, (str, unicode)):
                sys.stderr.write(message.encode(self.logging.local_encoding, 'replace'))

            elif isinstance(message, (list ,tuple)):
                for m in message:
                    sys.stderr.write(m.encode(self.logging.local_encoding, 'replace'))

            if log_target & 2:
                self.logging.log_queue.put([message, log_level, 2])

        else:
            self.logging.log_queue.put([message, log_level, log_target])

    # end log()

    def load_text(self, lang = 'en'):
        if lang == self.lang and self.texts != None:
            return

        name = 'tv_grab_text'
        fle_name = u'%s/texts/%s.%s' % (sys.path[0], name, lang)
        try:
            if os.path.isfile(fle_name):
                fle_dict = self.pdict = pickle.load(open(fle_name,'r'))
                if self.texts == None:
                    self.texts = fle_dict['texts']

                else:
                    self.lang = fle_dict['lang']
                    for module in fle_dict['texts'].keys():
                        if not module in self.texts.keys():
                            self.texts[module] = {}

                        for type in fle_dict['texts'][module].keys():
                            if not type in self.texts[module].keys():
                                self.texts[module][type] = {}

                            for tno in fle_dict['texts'][module][type].keys():
                                if not tno in self.texts[module][type].keys() or self.texts[module][type][tno] == '':
                                    self.texts[module][type][tno] = fle_dict['texts'][module][type][tno]

            else:
                self.log('Error loading text file: %s' % fle_name)

        except:
            self.log('Error loading text file: %s' % fle_name)

    # end load_text()

    def text(self, module = 'sources', tno = 0, addintuple = None, type = 'error'):
        try:
            if module in self.texts.keys():
                if type in self.texts[module].keys():
                    if tno in self.texts[module][type].keys():
                        txt = self.texts[module][type][tno]
                        if isinstance(addintuple, tuple) and len(addintuple) > 0:
                            txt = txt % addintuple

                        if isinstance(txt, unicode):
                            return txt

            return self.texts['config']['error'][0]

        except:
            return self.texts['config']['error'][-1]
    # end text()

    def init_sources(self):
        """Dummy  to be filled in"""
        pass
    # end init_sources()

    def validate_commandline(self):
        """Read the commandline and validate the values"""
        self.init_sources()
        self.sourceid_by_name = {}
        for k, v in self.channelsource.items():
            self.sourceid_by_name[v.source] = k
        if self.read_commandline() == 0:
             return(0)

        # The Query options
        for (a, o) in ((self.args.version, 'version'), \
                              (self.args.description, 'description'), \
                              (self.args.description_long, 'description_long'), \
                              (self.args.capabilities, 'capabilities'), \
                              (self.args.preferredmethod, 'preferredmethod'), \
                              (self.args.show_sources, 'show_sources'), \
                              (self.args.show_logo_sources, 'show_logo_sources'), \
                              (self.args.show_detail_sources, 'show_detail_sources')):
            if a:
                self.validate_option(o)
                return(0)

        # Check config and log file
        if self.args.config_file != self.opt_dict['config_file']:
            # use the provided name for configuration and logging
            self.opt_dict['config_file'] = self.args.config_file
            self.opt_dict['log_file'] = self.args.config_file+'.log'

        x = self.validate_option('config_file')
        if x != None:
            return(x)

        x = self.get_sourcematching_file(self.args.configure)
        if x != None:
            return(x)

        if self.args.quiet != None:
            self.opt_dict['quiet'] = self.args.quiet

        #check for cache
        if self.validate_option('cache_file') != None:
            return(2)

        if self.args.clear_cache or self.args.clear_ttvdb:
            return(0)

        if self.args.disable_ttvdb != None:
            self.opt_dict['disable_ttvdb'] = self.args.disable_ttvdb

        if self.opt_dict['disable_ttvdb'] == False:
            self.ttvdb = tv_grab_fetch.theTVDB(self)
            self.ttvdb.start()

        if self.args.ttvdb_title != None :
            return self.validate_option('check_ttvdb_title')

        # Check a possible output file
        if self.args.output_file != None:
            self.opt_dict['output_file'] = self.args.output_file

        if self.validate_option('output_file') != None:
            return(2)

        # Validate the options
        for s in self.args.disable_source:
            self.validate_option('disable_source', value = s)

        for s in self.args.disable_detail_source:
            self.validate_option('disable_detail_source', value = s)

        for (a, o) in ((self.args.compat, 'compat'), \
                              (self.args.legacy_xmltvids, 'legacy_xmltvids'), \
                              (self.args.fast, 'fast'), \
                              (self.args.logos, 'logos'), \
                              (self.args.mark_hd, 'mark_hd'), \
                              (self.args.cattrans, 'cattrans'), \
                              (self.args.slowdays, 'slowdays'), \
                              (self.args.desc_length, 'desc_length'), \
                              (self.args.overlap_strategy, 'overlap_strategy'), \
                              (self.args.max_overlap, 'max_overlap')):
            if a != None:
                self.opt_dict[o] = a
                for chanid in self.channels.keys():
                    self.channels[chanid].opt_dict[o] = self.opt_dict[o]

        self.offset = self.opt_dict['offset']
        for (a, o) in ((self.args.use_utc, 'use_utc'), \
                              (self.args.offset, 'offset'), \
                              (self.args.days, 'days')):
            if a != None:
                self.opt_dict[o] = a

        # limit days to maximum supported by the several sites
        for o in ('offset', 'days'):
            self.validate_option(o)

        # Continue validating the settings for the individual channels
        for chanid in self.channels.keys():
            self.channels[chanid].validate_settings()

        if not self.args.configure and self.configversion < float('%s.%s' % (self.api_major+2, self.api_minor)):
            # Update to the current version config
            if self.configversion == 1.0:
                self.write_defaults_list()

            if not self.write_config(None):
                self.log([self.text('config', 1), self.text('config', 2)])
                return(1)

            self.log([self.text('config', 3, (self.opt_dict['config_file'], )), \
                self.text('config', 4), self.text('config', 5)], 1, 1)
            return(0)

        self.write_opts_to_log()
        if self.args.configure:
            self.args.group_active_channels = self.opt_dict['group_active_channels'] | self.args.group_active_channels
            self.log(self.text('config', 6,(self.opt_dict['config_file'], )))
            if self.get_channels() == 69:
                return 69

            if not self.write_config(True):
                self.log(self.text('config', 7))
                self.IO_func.restore_oldfile(self.opt_dict['config_file'])
                return(1)

            self.log([self.text('config', 8, (self.opt_dict['config_file'], )), \
                self.text('config', 4), self.text('config', 5)], 1, 1)
            return(0)

        if self.args.save_options:
            if not self.write_config(False):
                self.log(self.text('config', 7))
                self.IO_func.restore_oldfile(self.opt_dict['config_file'])
                return(1)

            self.log([self.text('config', 9, (self.opt_dict['config_file'], )), self.text('config', 4)])
            return(0)

        self.read_defaults_list()

    # end validate_commandline()

    def validate_option(self, option, channel = None, value = None, stdoutput = True, check_default = False):
        """Validate an option"""
        if not (channel == None or channel in self.channels.values()):
            return

        if option == 'version':
            print("%s: %s" % (self.country, self.version(True)))
            print("The Netherlands: %s" % self.version(True, True))
            return(0)

        elif option == 'description':
            v=self.version()
            if v[6]:
                dtext = ("%s v%s.%s.%s-alfa" % (self.description, v[1], v[2], v[3]))

            elif v[5]:
                dtext = ("%s v%s.%s.%s-beta" % (self.description, v[1], v[2], v[3]))

            else:
                dtext = ("%s v%s.%s.%s" % (self.description, v[1], v[2], v[3]))

            if stdoutput:
                print(dtext)

            else:
                return(dtext)

        elif option == 'description_long':
            print("The Netherlands: %s" % self.version(True))
            print(description_text)
            return(0)

        elif option == 'capabilities':
            if stdoutput:
                print("baseline")
                print("cache")
                print("manualconfig")
                print("preferredmethod")

            else:
                return ("baseline", "cache", "manualconfig", "preferredmethod")

        elif option == 'preferredmethod':
            if stdoutput:
                 print('allatonce')

            else:
                 return('allatonce')

        elif option == 'show_sources':
            if stdoutput:
                print(self.text('config', 1, type='other'))
                for i, s in self.channelsource.items():
                    print('  %s: %s' % (i, s.source))

            else:
                tdict = {}
                for i, s in self.channelsource.items():
                    tdict[i] = s.source

                return tdict

        elif option == 'show_detail_sources':
            if stdoutput:
                print(self.text('config', 2, type='other'))
                for i, s in self.channelsource.items():
                    if i in self.detail_sources:
                        print('  %s: %s' % (i, s.source))

            else:
                tdict = {}
                for i, s in self.channelsource.items():
                    if s.detail_processor:
                        tdict[i] = s.source

                return tdict
        elif option == 'show_logo_sources':
            self.get_sourcematching_file(show_info=False)
            if stdoutput:
                print(self.text('config', 3, type='other'))
                for k, v in self.xml_output.logo_provider.items():
                    print('  %s: %s' % (k, v))

                print(self.text('config', 4, type='other'))

            else:
                tdict = {}
                for k, v in self.xml_output.logo_provider.items():
                    tdict[k] = v

                    tdict[99] = 'free-form'
                return tdict

        elif option == 'check_ttvdb_title':
            if self.opt_dict['disable_ttvdb']:
                self.log(self.text('config', 10))
                return(-2)

            if len(self.args.ttvdb_title) == 0:
                self.log(self.text('config', 11))
                return(-2)

            series_title = unicode(self.args.ttvdb_title[0], 'utf-8')
            lang = 'nl'
            if len(self.args.ttvdb_title) >1:
                lang = unicode(self.args.ttvdb_title[1], 'utf-8')[:2]
                if not lang in ('cs', 'da', 'de', 'el', 'en', 'es', 'fi', 'fr', 'he', 'hr', 'hu', 'it',
                                        'ja', 'ko', 'nl', 'no', 'pl', 'pt', 'ru', 'sl', 'sv', 'tr', 'zh'):
                    self.log(self.text('config', 12, (lang,)))

            if self.ttvdb.check_ttvdb_title(series_title, lang) == -1:
                return -1

        elif option == 'disable_source':
            if value in self.channelsource.keys():
                if channel == None:
                    if value not in self.opt_dict['disable_source']:
                        self.opt_dict['disable_source'].append(value)

                elif channel.get_source_id(value) != '':
                    if value not in channel.opt_dict['disable_source']:
                        channel.opt_dict['disable_source'].append(value)

                    if value in self.detail_sources and value not in channel.opt_dict['disable_detail_source']:
                        channel.opt_dict['disable_detail_source'].append(value)

        elif option == 'disable_detail_source':
            if value in self.detail_sources:
                if channel == None:
                    if value not in self.opt_dict['disable_detail_source']:
                        self.opt_dict['disable_detail_source'].append(value)

                elif channel.get_source_id(value) != '':
                    if value not in channel.opt_dict['disable_detail_source']:
                        channel.opt_dict['disable_detail_source'].append(value)

        elif option == 'prime_source':
            if channel == None:
                return

            # First get the default
            def_value = -1
            if channel.group in self.prime_source_groups and channel.get_source_id(self.prime_source_groups[channel.group]) != '' \
                and not (self.prime_source_groups[channel.group] in self.opt_dict['disable_source'] \
                or self.prime_source_groups[channel.group] in channel.opt_dict['disable_source'] \
                or channel.get_source_id(self.prime_source_groups[channel.group]) in self.channelsource[self.prime_source_groups[channel.group]].no_genric_matching):
                #~ or channel.get_source_id(self.prime_source_groups[channel.group]) in self.no_genric_matching[self.prime_source_groups[channel.group]]):
                    # A group default in sourcematching.json
                    def_value = self.prime_source_groups[channel.group]

            else:
                for s in self.prime_source_order:
                    if channel.get_source_id(s) != '' \
                        and not (s in self.opt_dict['disable_source'] or s in channel.opt_dict['disable_source'] \
                        or channel.get_source_id(s) in self.channelsource[s].no_genric_matching):
                        #~ or channel.get_source_id(s) in self.no_genric_matching[s]):
                            # The first available not set in no_genric_matching
                            def_value = s
                            break

                else:
                    for s in self.prime_source_order:
                        if channel.get_source_id(s) != '' \
                            and not (s in self.opt_dict['disable_source'] or s in channel.opt_dict['disable_source']):
                                # The first available
                                def_value = s
                                break

            # Now we check for a custom value
            if value == None:
                value = channel.opt_dict['prime_source']

            custom_value = None
            if value in self.channelsource.keys() and channel.get_source_id(value) != '' \
                and not (value in self.opt_dict['disable_source'] or value in channel.opt_dict['disable_source']) \
                and value != def_value:
                    # It's a valid custom value not equal to the default
                    custom_value = value

            json_value = None
            if channel.chanid in self.prime_source.keys() and channel.get_source_id(self.prime_source[channel.chanid]) != '' \
                and not (self.prime_source[channel.chanid] in self.opt_dict['disable_source'] \
                or self.prime_source[channel.chanid] in channel.opt_dict['disable_source']):
                    # Use an override in sourcematching.json
                    json_value = self.prime_source[channel.chanid]

            if self.opt_dict['always_use_json']:
                for v in (json_value, custom_value):
                    #~ if v != None and not channel.get_source_id(v) in self.no_genric_matching[v]:
                    if v != None and not channel.get_source_id(v) in self.channelsource[v].no_genric_matching:
                        value = v
                        break

                else:
                    value = def_value

            else:
                for v in (custom_value, json_value):
                    #~ if v != None and not channel.get_source_id(v) in self.no_genric_matching[v]:
                    if v != None and not channel.get_source_id(v) in self.channelsource[v].no_genric_matching:
                        value = v
                        break

                else:
                    value = def_value

            if check_default:
                return bool((value == def_value) or (value == -1))

            else:
                channel.opt_dict['prime_source'] = value

        elif option == 'prefered_description':
            if channel == None:
                return

            if value == None:
                value = channel.opt_dict['prefered_description']

            if value in self.channelsource.keys() and channel.get_source_id(value) != '' \
                and not (value in self.opt_dict['disable_source'] or value in channel.opt_dict['disable_source']):
                    channel.opt_dict['prefered_description'] = value

            else:
                channel.opt_dict['prefered_description'] = -1

        elif option == 'offset':
            if self.opt_dict['offset'] > 14:
                if self.offset < 14:
                    self.log(self.text('config', 13, (self.opt_dict['offset'], self.offset)),1,1)
                    self.opt_dict['offset'] = self.offset

                else:
                    self.log(self.text('config', 13, (self.opt_dict['offset'], '0')),1,1)
                    self.opt_dict['offset'] = 0

        elif option == 'days':
            if self.opt_dict['days'] > (14 - self.opt_dict['offset']):
                self.log(self.text('config', 14),1,1)

            self.opt_dict['days'] = min(self.opt_dict['days'],(14 - self.opt_dict['offset']))

            if self.opt_dict['slowdays'] == None or self.opt_dict['slowdays'] > self.opt_dict['days']:
                self.opt_dict['slowdays'] = self.opt_dict['days']

        elif option == 'output_file':
            if self.opt_dict['output_file'] != None:
                try:
                    output_dir = os.path.dirname(self.opt_dict['output_file'])
                    if (output_dir != '') and not os.path.exists(output_dir):
                        self.log(self.text('config', 15, (output_dir, )))
                        os.mkdir(output_dir)

                    if self.args.output_codeset:
                        self.xml_output.xmlencoding = 'CP1252'
                        self.output = self.IO_func.open_file(self.opt_dict['output_file'],'w', 'windows-1252')

                    else:
                        self.output = self.IO_func.open_file(self.opt_dict['output_file'],'w')

                    if self.output == None:
                        self.log(self.text('config', 16, (self.opt_dict['output_file'],)))
                        return(2)

                except:
                    self.log([self.text('config', 16, (self.opt_dict['output_file'],)), traceback.format_exc()])
                    return(2)

            else: self.output = None

        elif option == 'config_file':
            # Save an old session log and open a new one
            try:
                # check for the config/log dir
                config_dir = os.path.dirname(self.opt_dict['config_file'])
                if (config_dir != '') and not os.path.exists(config_dir):
                    self.log(self.text('config', 15, (config_dir,)))
                    os.mkdir(config_dir)

                else:
                    self.IO_func.save_oldfile(self.opt_dict['log_file'])

            except:
                self.logging.writelog(self.text('config', 17, (config_dir, )), 0,1)
                self.logging.writelog(traceback.format_exc(), 0,1)
                return(2)

            try:
                self.log_output = self.IO_func.open_file(self.opt_dict['log_file'], mode = 'a')
                if self.log_output == None:
                    self.logging.writelog(self.text('config', 18, (self.opt_dict['log_file'], )), 0,1)
                    return(2)

                self.logging.start()

            except:
                self.logging.writelog(traceback.format_exc(), 0,1)
                self.logging.writelog(self.text('config', 18, (self.opt_dict['log_file'], )), 0,1)
                return(2)

            self.log(self.text('config', 19, (self.opt_dict['config_file'], )))
            # get config if available Overrule if set by commandline
            if not self.read_config() and not self.args.configure:
                return(1)

        elif option == 'cache_file':
            if self.args.cache_file != self.opt_dict['cache_file']:
                self.opt_dict['cache_file'] = self.args.cache_file

            if self.opt_dict['cache_file'].lower() == 'none' or self.opt_dict['cache_file'] == None:
                self.opt_dict['cache_file'] = None
                self.program_cache = tv_grab_IO.ProgramCache(self, self.opt_dict['cache_file'])
                self.program_cache.start()
                return

            try:
                cache_dir = os.path.dirname(self.opt_dict['cache_file'])
                if (cache_dir != '') and not os.path.exists(cache_dir):
                    self.log(self.text('config', 15, (cache_dir, )))
                    os.mkdir(cache_dir)

                if os.access(self.opt_dict['cache_file'], os.F_OK and os.W_OK):
                    pass

                elif not os.path.isfile(self.opt_dict['cache_file']) and os.access(cache_dir, os.W_OK):
                    pass

                else:
                    self.log(self.text('config', 20, (self.opt_dict['cache_file'], )))
                    return(2)

            except:
                self.log([self.text('config', 21, (self.opt_dict['cache_file'], )), traceback.format_exc()])
                return(2)

            self.program_cache = tv_grab_IO.ProgramCache(self, self.opt_dict['cache_file'])
            self.program_cache.start()
            if self.args.clear_cache:
                self.program_cache.cache_request.put({'task':'clear'})

            elif self.args.clean_cache:
                self.program_cache.cache_request.put({'task':'clean'})

            if self.args.clear_ttvdb:
                self.program_cache.cache_request.put({'task':'clear', 'table':['ttvdb', 'episodes']})

        elif option == 'slowdays':
            if channel == None:
                if self.opt_dict['slowdays'] == None:
                    self.opt_dict['slowdays'] = self.opt_dict['days']
                    if self.opt_dict['desc_length'] == 0:
                        # no description implies fast == True
                        if not self.opt_dict['fast']:
                            self.log(self.text('config', 22),1,1)
                            self.opt_dict['fast'] = True

                else:
                    self.opt_dict['slowdays'] = min(self.opt_dict['days'], self.opt_dict['slowdays'])
                    # slowdays implies fast == False
                    if self.opt_dict['slowdays'] < self.opt_dict['days']:
                        self.opt_dict['fast']  = False

            else:
                if channel.opt_dict['slowdays'] == None:
                    channel.opt_dict['slowdays'] = self.opt_dict['days']
                    if channel.opt_dict['desc_length'] == 0:
                        # no description implies fast == True
                        if not channel.opt_dict['fast']:
                            self.log(self.text('config', 23, (channel.chan_name, )),1,1)
                            channel.opt_dict['fast'] = True

                else:
                    channel.opt_dict['slowdays'] = min(self.opt_dict['days'], channel.opt_dict['slowdays'])
                    # slowdays implies fast == False
                    if channel.opt_dict['slowdays'] < self.opt_dict['days']:
                        channel.opt_dict['fast']  = False

        elif option == 'desc_length':
            if channel != None and channel.opt_dict['desc_length'] != self.opt_dict['desc_length']:
                self.log(self.text('config', 24, (channel.opt_dict['desc_length'], channel.chan_name)),1,1)

        elif option == 'overlap_strategy':
            if channel == None:
                if not self.opt_dict['overlap_strategy'] in ['average', 'stop', 'start']:
                    self.opt_dict['overlap_strategy'] = 'none'

            else:
                if not channel.opt_dict['overlap_strategy'] in ['average', 'stop', 'start']:
                    channel.opt_dict['overlap_strategy'] = 'none'

        elif option == 'max_overlap':
            if channel == None:
                if self.opt_dict['max_overlap'] == 0:
                    # no max_overlap implies strategie == 'None'
                    self.opt_dict['overlap_strategy'] = 'None'
                    self.log(self.text('config', 25, (self.opt_dict['overlap_strategy'], )),1,1)

            elif channel.opt_dict['max_overlap'] == 0:
                # no max_overlap implies strategie == 'None'
                channel.opt_dict['overlap_strategy'] = 'None'
                self.log(self.text('config', 26, (channel.chan_name, channel.opt_dict['overlap_strategy'])),1,1)

            elif channel.opt_dict['max_overlap'] != self.opt_dict['max_overlap']:
                self.log(self.text('config', 27, (channel.opt_dict['max_overlap'], channel.chan_name)),1,1)
                if channel.opt_dict['overlap_strategy'] != self.opt_dict['overlap_strategy']:
                    self.log(self.text('config', 28, (channel.chan_name, channel.opt_dict['overlap_strategy'])),1,1)

    # end validate_option()

    def read_commandline(self):
        """Initiate argparser and read the commandline"""
        description = u"%s: %s\n" % (self.country, self.version(True)) + \
                        u"The Netherlands: %s\n" % self.version(True, True) + \
                        self.text('config', 29) + self.text('config', 30)

        parser = argparse.ArgumentParser(description = description, formatter_class=argparse.RawTextHelpFormatter)

        parser.add_argument('-V', '--version', action = 'store_true', default = False, dest = 'version',
                        help = self.text('config', 5, type='other'))

        parser.add_argument('--description', action = 'store_true', default = False, dest = 'description',
                        help =self.text('config', 6, type='other'))

        parser.add_argument('-d', '--long-descr', action = 'store_true', default = False, dest = 'description_long',
                        help =self.text('config', 7, type='other'))

        parser.add_argument('--capabilities', action = 'store_true', default = False, dest = 'capabilities',
                        help =self.text('config', 8, type='other'))

        parser.add_argument('--preferredmethod', action = 'store_true', default = False, dest = 'preferredmethod',
                        help =self.text('config', 9, type='other'))

        parser.add_argument('--show-sources', action = 'store_true', default = False, dest = 'show_sources',
                        help =self.text('config', 10, type='other'))

        parser.add_argument('--disable-source', action = 'append', default = [], dest = 'disable_source',
                        metavar = '<source ID>', type = int, help =self.text('config', 11, type='other'))

        parser.add_argument('--show-detail-sources', action = 'store_true', default = False, dest = 'show_detail_sources',
                        help =self.text('config', 12, type='other'))

        parser.add_argument('--show-logo-sources', action = 'store_true', default = False, dest = 'show_logo_sources',
                        help =self.text('config', 13, type='other'))

        parser.add_argument('--disable-detail-source', action = 'append', default = [], dest = 'disable_detail_source',
                        metavar = '<source ID>', type = int, help =self.text('config', 15, type='other'))

        parser.add_argument('--disable-ttvdb', action = 'store_true', default = None, dest = 'disable_ttvdb',
                        help =self.text('config', 16, type='other'))

        parser.add_argument('--add-ttvdb-title', nargs = '*', metavar = '<title>', dest = 'ttvdb_title',
                        help =self.text('config', 17, type='other'))

        parser.add_argument('-x', '--compat', action = 'store_true', default = None, dest = 'compat',
                        help =self.text('config', 18, type='other'))

        parser.add_argument('-X', '--legacy_xmltvids', action = 'store_true', default = None, dest = 'legacy_xmltvids',
                        help =self.text('config', 19, type='other'))

        parser.add_argument('-u', '--utc', action = 'store_true', default = None, dest = 'use_utc',
                        help =self.text('config', 20, type='other'))

        parser.add_argument('-c', '--configure', action = 'store_true', default = False, dest = 'configure',
                        help =self.text('config', 21, type='other'))

        parser.add_argument('--group_active_channels', action = 'store_true', default = False, dest = 'group_active_channels',
                        help =self.text('config', 22, type='other'))

        parser.add_argument('-C', '--config-file', type = str, default = self.opt_dict['config_file'], dest = 'config_file',
                        metavar = '<file>', help =self.text('config', 23, (self.opt_dict['config_file'], ), type='other'))

        parser.add_argument('-O', '--save-options', action = 'store_true', default = False, dest = 'save_options',
                        help =self.text('config', 24, type='other'))

        parser.add_argument('-A', '--cache', type = str, default = self.opt_dict['cache_file'], dest = 'cache_file',
                        metavar = '<file>', help =self.text('config', 25, (self.opt_dict['cache_file'], ), type='other'))

        parser.add_argument('--clean_cache', action = 'store_true', default = self.clean_cache, dest = 'clean_cache',
                        help =self.text('config', 26, type='other'))

        parser.add_argument('--clear_cache', '--clear-cache', action = 'store_true', default = self.clear_cache, dest = 'clear_cache',
                        help =self.text('config', 27, type='other'))

        parser.add_argument('--clear_ttvdb', '--clear-ttvdb', action = 'store_true', default = self.clear_cache, dest = 'clear_ttvdb',
                        help =self.text('config', 28, type='other'))

        parser.add_argument('-W', '--output', type = str, default = None, dest = 'output_file',
                        metavar = '<file>', help =self.text('config', 29, type='other'))

        parser.add_argument('--output-windows-codeset',  action = 'store_true', default = False, dest = 'output_codeset',
                        help =self.text('config', 30, type='other'))

        parser.add_argument('-q', '--quiet', action = 'store_true', default = None, dest = 'quiet',
                        help =self.text('config', 31, type='other'))

        parser.add_argument('-v', '--verbose', action = 'store_false', default = None, dest = 'quiet',
                        help =self.text('config', 32, type='other'))

        parser.add_argument('-f', '--fast', action = 'store_true', default = None, dest = 'fast',
                        help =self.text('config', 33, type='other'))

        parser.add_argument('-s', '--slow', action = 'store_false', default = None, dest = 'fast',
                        help =self.text('config', 34, type='other'))

        parser.add_argument('-o', '--offset', type = int, default = None, dest = 'offset',
                        metavar = '<days>', help =self.text('config', 35, type='other'))

        parser.add_argument('-g', '--days', type = int, default = None, dest = 'days',
                        metavar = '<days>', help =self.text('config', 36, type='other'))

        parser.add_argument('-G', '--slowdays', type = int, default = None, dest = 'slowdays',
                        metavar = '<days>', help =self.text('config', 38, type='other'))

        parser.add_argument('--logos', action = 'store_true', default = None, dest = 'logos',
                        help =self.text('config', 39, type='other'))

        parser.add_argument('-n', '--nologos', action = 'store_false', default = None, dest = 'logos',
                        help =self.text('config', 40, type='other'))

        parser.add_argument('-H', '--mark-HD', action = 'store_true', default = None, dest = 'mark_hd',
                        help =self.text('config', 41, type='other'))

        parser.add_argument('--cattrans', action = 'store_true', default = None, dest = 'cattrans',
                        help =self.text('config', 42, (self.name,), type='other'))

        parser.add_argument('-t', '--nocattrans', action = 'store_false', default = None, dest = 'cattrans',
                        help =self.text('config', 43, type='other'))

        parser.add_argument('-l ', '--desc-length', type = int, default = None, dest = 'desc_length',
                        metavar = '<bytes>', help =self.text('config', 44, type='other'))

        parser.add_argument('-a', '--overlap_strategy', type = str, default = None, dest = 'overlap_strategy',
                        metavar = '<strategy>', help =self.text('config', 45, type='other'))

        parser.add_argument('-m', '--max_overlap', type = int, default = None, dest = 'max_overlap',
                        metavar = '<minutes>', help =self.text('config', 46, type='other'))

        # Handle the sys.exit(0) exception on --help more gracefull
        try:
            self.args = parser.parse_args()

        except:
            return(0)

    # end read_commandline()

    def read_config(self):
        """Read the configurationfile Return False on failure."""
        self.config_dict = {1:[], 2:[], 3:[], 9:{}}
        f = self.IO_func.open_file(self.opt_dict['config_file'])
        if f == None:
            if not self.args.configure:
                self.log(self.text('config', 31))
            return False

        if not self.IO_func.check_encoding(f, None, True):
            return False

        self.encoding = self.IO_func.encoding
        self.configversion = self.IO_func.configversion
        if self.configversion == 1.0:
            type = 2
            section = self.__CONFIG_SECTIONS__[2]

        else:
            type = 0
            section = ''
            if self.configversion < 2.208:
                self.log(self.text('config', 32), 0)
                self.opt_dict['legacy_xmltvids'] = True
                if not self.args.configure:
                    self.log(self.text('config', 33), 0)

        # Read the configuration into the self.config_dict dictionary
        f.seek(0,0)
        for byteline in f.readlines():
            try:
                line = self.IO_func.get_line(f, byteline, None, self.encoding)
                if not line:
                    continue

                if line[0:1] == '#' and type != 3:
                    continue

                # Look for section headers
                config_title = re.search('\[(.*?)\]', line)
                if config_title != None:
                    if (config_title.group(1) in self.__CONFIG_SECTIONS__.values()):
                        section = config_title.group(1)
                        for i, v in self.__CONFIG_SECTIONS__.items():
                            if v == config_title.group(1):
                                type = i
                                continue

                        continue

                    # Itś a channel confuration
                    elif config_title.group(1)[0:7].lower() == 'channel':
                        section = config_title.group(1)[7:].strip().lower()
                        type = 9
                        if not section in self.config_dict[9].keys():
                            self.config_dict[9][section] = []
                        continue

                    # Unknown Section header, so ignore
                    else:
                        self.log(self.text('config', 34, (config_title.group(1), )))
                        section = ''
                        type = 0

                # Unknown Section header, so ignore
                elif line[0:1] == '[':
                    section = ''
                    type = 0
                    continue

                if type in (1, 2, 3):
                    self.config_dict[type].append(line)

                elif type == 9:
                    self.config_dict[9][section].append(line)

                else:
                    self.log(self.text('config', 35, (line, )))


            except:
                self.log([self.text('config', 36), traceback.format_exc()])
                continue

        f.close()
        # Read the General Configuration options
        for line in self.config_dict[1]:
            try:
                # Strip the name from the value
                a = re.split('=',line)
                cfg_option = a[0].lower().strip()
                # Boolean Values
                if cfg_option in ('write_info_files', 'quiet', 'fast', 'compat', 'logos', 'cattrans', 'mail_log', \
                  'mark_hd', 'use_utc', 'disable_ttvdb', 'use_split_episodes', 'group_active_channels', \
                  'always_use_json', 'legacy_xmltvids'):
                    if len(a) == 1:
                        self.opt_dict[cfg_option] = True

                    elif a[1].lower().strip() in ('true', '1' , 'on'):
                        self.opt_dict[cfg_option] = True

                    else:
                        self.opt_dict[cfg_option] = False

                # String values that can be None
                elif cfg_option in ('output_file', 'mail_info_address'):
                    self.opt_dict[cfg_option] = None if (len(a) == 1 or a[1].lower().strip() == 'none') else a[1].strip()

                elif len(a) == 2:
                    cfg_value = a[1].lower().strip()
                    if cfg_option == 'use_npo':
                        if cfg_value in ('false', '0' , 'off'):
                            self.validate_option('disable_source', value = 4)

                    # String values
                    elif cfg_option in ('mailserver', 'mail_log_address'):
                        self.opt_dict[cfg_option] = a[1].strip()

                    # Select Values
                    elif cfg_option == 'overlap_strategy':
                        if cfg_value in ('average', 'stop', 'start'):
                            self.opt_dict[cfg_option] = cfg_value

                        else:
                            self.opt_dict[cfg_option] = 'none'

                    elif cfg_option == 'kijkwijzerstijl':
                        if cfg_value in ('long', 'short', 'single'):
                            self.opt_dict[cfg_option] = cfg_value

                        else:
                            self.opt_dict[cfg_option] = 'none'

                    # Integer Values
                    elif cfg_option in ('log_level', 'match_log_level', 'offset', 'days', 'slowdays', 'mailport', \
                      'max_overlap', 'desc_length', 'disable_source', 'disable_detail_source', 'data_version', \
                      'max_simultaneous_fetches', 'global_timeout'):
                        try:
                            cfg_value = int(cfg_value)

                        except ValueError:
                            if (cfg_option == 'slowdays') and (cfg_value == 'none'):
                                self.opt_dict[cfg_option] = None

                        else:
                            if cfg_option in ('disable_source', 'disable_detail_source'):
                                self.validate_option(cfg_option, value = cfg_value)

                            else:
                                self.opt_dict[cfg_option] = cfg_value

            except:
                self.log([self.text('config', 37, (self.opt_dict['config_file'],)),'%r\n' % (line)])

        # Read the channel stuff up to version 2.0
        channel_names = {}
        old_chanids = {}
        if self.configversion <= 2.0:
            for line in self.config_dict[2]:
                try:
                    channel = line.split(None, 1) # split on first whitespace
                    self.channels[unicode(channel[0]).strip()] = tv_grab_fetch.Channel_Config(self, unicode(channel[0]).strip(), unicode(channel[1]).strip())
                    self.channels[unicode(channel[0]).strip()].active = True
                    channel_names[unicode(channel[1]).strip().lower()] = unicode(channel[0]).strip()

                except:
                    self.log([self.text('config', 38, (self.opt_dict['config_file'], )),'%r\n' % (line)])

        # Changed Channel config since version 2.1
        if self.configversion >= 2.1:
            test_as_21 = False
            for line in self.config_dict[3]:
                try:
                    if line[0:1] == '#':
                        active = False
                        line = line.lstrip('#').lstrip()

                    else:
                        active = True

                    channel = re.split(';', line)
                    if len(channel) < 6:
                        # A configuration line with less then six has no chanids
                        continue

                    # Test to catch early 2.2 configurations without a chanid
                    try:
                        if self.configversion > 2.1:
                            if channel[2].strip() == '':
                                test_as_21 = True

                            else:
                                x = int(channel[2])
                                test_as_21 = True

                    except:
                        pass

                    if self.configversion == 2.1 or test_as_21:
                        # Read an old channel string
                        if len(channel) != 8 and not test_as_21:
                            # A 2.1  configuration line must contain 8 items
                            continue

                        for index in range(self.source_count):
                            if channel[index + 2].strip() != '':
                                old_chanid = unicode(channel[index + 2]).strip()
                                break

                        else:
                            # No sources!
                            continue

                        chanid = u'%s-%s' % (index, old_chanid)
                        old_chanids[old_chanid] = chanid
                        self.channels[chanid] = tv_grab_fetch.Channel_Config(self, chanid, unicode(channel[0]).strip(), int(channel[1]))
                        for index in range(4):
                            self.channels[chanid].source_id[index] = unicode(channel[index + 2]).strip()

                    else:
                        # And the new version 2.2 one
                        for index in range(min(self.source_count,len(channel) - 5)):
                            if channel[index + 3].strip() != '':
                                break

                        else:
                            # No sources!
                            continue

                        chanid = unicode(channel[2])
                        channel_names[unicode(channel[0]).strip().lower()] = chanid
                        self.channels[chanid] = tv_grab_fetch.Channel_Config(self, chanid, unicode(channel[0]).strip(), int(channel[1]))
                        for index in range(min(self.source_count,len(channel) - 5)):
                            self.channels[chanid].source_id[index] = unicode(channel[index + 3]).strip()

                    # The icon defenition
                    self.channels[chanid].icon_source = int(channel[-2])
                    self.channels[chanid].icon = unicode(channel[-1]).strip()
                    # fill in the default options
                    for i, v in self.opt_dict.items():
                        if i in self.channels[chanid].opt_dict.keys() and not i in ('disable_source', 'disable_detail_source'):
                            self.channels[chanid].opt_dict[i] = v

                    # set the default prime_source
                    #~ self.validate_option('prime_source', self.channels[chanid], -1)
                    # Set active if not remarked out
                    self.channels[chanid].active = active
                    if active:
                        self.chan_count += 1

                except:
                    self.log([self.text('config', 38, (self.opt_dict['config_file'], )),'%r\n' % (line), traceback.format_exc()])

            # Read the channel specific configuration
            for section, values in self.config_dict[9].items():
                if self.configversion == 2.1 or test_as_21:
                    if section in old_chanids.keys():
                        chanid = old_chanids[section]

                    else:
                        continue

                # is the name in the sectionheader a known chanid?
                elif section in self.channels.keys():
                    chanid = section

                # or a known channelname
                elif section in channel_names.keys():
                    chanid = channel_names[section]

                else:
                    # unknown chanid or channelname
                    self.log(self.text('config', 39, (section, )))
                    continue

                for line in values:
                    try:
                        # Strip the name from the value
                        a = re.split('=',line)
                        cfg_option = a[0].lower().strip()
                        # Boolean Values
                        if cfg_option in ('fast', 'compat', 'logos', 'cattrans', 'mark_hd', 'add_hd_id', \
                          'append_tvgidstv', 'disable_ttvdb', 'use_split_episodes', 'legacy_xmltvids'):
                            if len(a) == 1:
                                self.channels[chanid].opt_dict[cfg_option] = True

                            elif a[1].lower().strip() in ('true', '1' , 'on'):
                                self.channels[chanid].opt_dict[cfg_option] = True

                            else:
                                self.channels[chanid].opt_dict[cfg_option] = False

                        elif len(a) == 2:
                            cfg_value = a[1].lower().strip()
                            if cfg_option == 'use_npo':
                                if cfg_value in ('false', '0' , 'off'):
                                    self.validate_option('disable_source', self.channels[chanid], 4)

                            # String values
                            elif cfg_option in ('xmltvid_alias', ):
                                self.channels[chanid].opt_dict[cfg_option] = cfg_value.strip()

                            # Select Values
                            elif cfg_option == 'overlap_strategy':
                                if cfg_value in ('average', 'stop', 'start'):
                                    self.channels[chanid].opt_dict[cfg_option] = cfg_value

                                else:
                                    self.channels[chanid].opt_dict[cfg_option] = 'none'

                            # Integer Values
                            elif cfg_option in ('slowdays', 'max_overlap', 'desc_length'):
                                try:
                                    cfg_value = int(cfg_value)

                                except ValueError:
                                    if (cfg_option == 'slowdays') and (cfg_value == 'none'):
                                        self.channels[chanid].opt_dict[cfg_option] = None

                                else:
                                    self.channels[chanid].opt_dict[cfg_option] = cfg_value

                            # Source Values
                            elif cfg_option in ('prime_source', 'prefered_description', 'disable_source', 'disable_detail_source'):
                                try:
                                    cfg_value = int(cfg_value)

                                except ValueError:
                                    continue

                                else:
                                    if cfg_option == 'prime_source':
                                        # We have to validate this value after reading sourcematching.json
                                        self.channels[chanid].prevalidate_opt[cfg_option] = cfg_value

                                    else:
                                        self.validate_option(cfg_option, self.channels[chanid], cfg_value)

                    except:
                        self.log([self.text('config', 40, (section, self.opt_dict['config_file'], )),'%r\n' % (line), traceback.format_exc()])

        # an extra option for gathering extra info to better the code
        if 'write_info_files' in self.opt_dict.keys():
            self.write_info_files = self.opt_dict['write_info_files']
            if self.write_info_files :
                self.infofiles = tv_grab_IO.InfoFiles(self)

        return True
    # end read_config()

    def read_defaults_list(self):
        """
        Get the genre conversion table, the title split exception list and others
        """
        f = self.IO_func.open_file(self.opt_dict['settings_file'])
        if f == None:
            return False

        if not self.IO_func.check_encoding(f):
            return False

        self.encoding = self.IO_func.encoding
        f.seek(0,0)
        type = 0
        for byteline in f.readlines():
            try:
                line = self.IO_func.get_line(f, byteline, False, self.encoding)
                if not line:
                    continue

                # Look for section headers
                config_title = re.search('\[(.*?)\]', line)
                if config_title != None and (config_title.group(1) in self.__DEFAULT_SECTIONS__.values()):
                    for i, v in self.__DEFAULT_SECTIONS__.items():
                        if v == config_title.group(1):
                            type = i
                            continue

                    # Ignore the defaults if section exists
                    if type == 3:
                        self.groupnameremove = []

                    elif type == 4:
                        self.titlerename = {}

                    continue

                # Unknown Section header, so ignore
                if line[0:1] == '[':
                    type = 0
                    continue

                if type == 1:
                    # split of the translation (if present) or supply an empty one
                    a = re.split('=',line)
                    if len(a) == 1:
                        a.append('')

                    # split main and sub-genre (if present) and if they have a translation
                    # (overwriting the default) or are not yet pressent add them to cattrans
                    g = re.split(':', a[0].lower() )
                    if len(g) == 2:
                        if not ((g[0].strip(), g[1].strip()) in self.cattrans and a[1].strip() == ''):
                            self.cattrans[ (g[0].strip(), g[1].strip())] = a[1].strip()

                    elif len(g) == 1:
                        if not ((g[0].strip(), g[1].strip()) in self.cattrans and a[1].strip() == ''):
                            self.cattrans[ (g[0].strip(), '')] = a[1].strip()

                elif type == 2:
                    line = line.lower()
                    if not line in self.notitlesplit:
                        self.notitlesplit.append(line)

                elif type == 3:
                    line = line.lower()
                    if not line in self.groupnameremove:
                        self.groupnameremove.append(line)

                elif type == 4:
                    # split of the translation (if present) or supply an empty one
                    a = re.split('=',line)
                    if len(a) == 1:
                        continue

                    self.titlerename[a[0].lower().strip()] = a[1].strip()

                elif type == 5:
                    # split of the translation (if present) or supply an empty one
                    a = re.split('=',line)
                    if len(a) == 1:
                        self.source_cattrans[3][a[0].lower().strip()] = (u'Overige', u'')
                        continue

                    # split main and sub-genre (if present) and add or overwrite the default
                    g = re.split(':', a[1].lower() )
                    if len(g) == 2:
                        self.source_cattrans[3][a[0].lower().strip()] = (g[0].strip(), g[1].strip())
                        continue

                    self.source_cattrans[3][a[0].lower().strip()] = (g[0].strip(), u'')

                elif type == 6:
                    # split of the translation (if present) or supply an empty one
                    a = re.split('=',line)
                    if len(a) == 1:
                        continue

                    if len(a[1]) > 20:
                        continue

                    self.source_cattrans[1][a[1].lower().strip()] = a[0].strip()

                elif type == 7:
                    # split of the translation (if present) or supply an empty one
                    a = re.split('=',line)
                    if len(a) == 1:
                        continue

                    self.roletrans[a[0].lower().strip()] = a[1].strip()
                elif type in (8, 9, 10, 11, 13, 14):
                    source = type - 4
                    # split of the translation (if present) or supply an empty one
                    a = line.split('=',1)
                    # split the source in main and sub
                    s = a[0].lower().strip()
                    if type in (8, 9):
                        s = s.split(':', 1)
                        if len(s) == 2:
                            s = (s[0].strip(), s[1].strip())

                    if len(a) == 1:
                        self.source_cattrans[source][s] = (u'Overige', u'')
                        continue

                    # split main and sub-genre (if present) and add or overwrite the default
                    g = a[1].lower().split(':', 1)
                    if len(g) == 2:
                        self.source_cattrans[source][s] = (g[0].strip(), g[1].strip())
                        continue

                    self.source_cattrans[source][s] = (g[0].strip(), u'')


            except:
                self.log([self.text('config', 41, (self.opt_dict['settings_file'], )), traceback.format_exc()])
                continue

        f.close()
        return True

    #end read_defaults_list()

    def get_sourcematching_file(self, configuring = False, show_info = True):
        # This gets grabed after reading the config
        def get_githubdict(gvar, intlevels = 0):
            lvar = {}
            try:
                if not gvar in githubdata:
                    return lvar.copy()

                if intlevels == 0:
                    return githubdata[gvar]

                for s, v in githubdata[gvar].items():
                    if intlevels == 1:
                        lvar[int(s)] = v

                    elif intlevels == 2:
                        lvar[int(s)] = {}
                        for g, clist in v.items():
                            lvar[int(s)][int(g)] = clist

                return lvar.copy()

            except:
                self.log(self.text('config', 42, (gvar,)))
                return lvar.copy()

        def get_githubdata(gvar, default = []):
            try:
                if not gvar in githubdata:
                    if isinstance(default,(list, tuple)):
                        return list(default)[:]

                    else:
                        return default

                if isinstance(githubdata[gvar],list):
                    lvar = default[:]
                    for t in githubdata[gvar]:
                        if not t in default:
                            lvar.append(t)

                    return lvar[:]

            except:
                self.log(self.text('config', 42, (gvar,)))
                return default

        try:
            fle = self.IO_func.open_file('%s/sources/tv_grab_API.json' % (sys.path[0]), 'r', 'utf-8')
            githubdata = json.load(fle)
            fle = self.IO_func.open_file('%s/sources/%s' % (sys.path[0], self.datafile), 'r', 'utf-8')
            githubdata2 = json.load(fle)
            for k, v in githubdata2.items():
                githubdata[k] = v
            #~ url = 'https://raw.githubusercontent.com/tvgrabbers/sourcematching/master/sourcematching.json'
            #~ githubdata = self.fetch_func.get_page(url, 'utf-8', is_json = True)
            #~ # Check on data or program updates
            #~ dv = int(githubdata["data_version"])
            #~ nv = githubdata["program_version"]
            #~ pv = u'%s.%s.%s' % (self.api_major+2, self.api_minor, self.api_patch)
            #~ if not "data_version" in self.opt_dict:
                #~ self.opt_dict["data_version"] = 0

            #~ if pv < nv or (pv == nv and (self.alfa or self.beta)):
                #~ loglist = ['There is a newer stable release available on github!\n']
                #~ if "version_message" in githubdata:
                    #~ if isinstance(githubdata["version_message"], (str, unicode)):
                        #~ loglist.append(githubdata["version_message"])

                    #~ elif isinstance(githubdata["version_message"], list):
                        #~ loglist.extend(githubdata["version_message"])

                #~ loglist.append("Goto: https://github.com/tvgrabbers/tvgrabnlpy/releases/latest\n")
                #~ if show_info:
                    #~ self.log(loglist, 0)

            #~ elif dv > self.opt_dict["data_version"]:
                #~ loglist = ['The channel/source matching data on github is newer!\n']
                #~ if "warning_message_2" in githubdata:
                    #~ for v, tekst in githubdata["warning_message_2"].items():
                        #~ if int(v) > self.opt_dict["data_version"]:
                            #~ if isinstance(tekst, (str, unicode)):
                                #~ loglist.append(tekst)

                            #~ elif isinstance(tekst, list):
                                #~ loglist.extend(tekst)

                #~ if not configuring:
                    #~ loglist.append("Run with '--configure' to implement it\n")

                #~ if show_info:
                    #~ self.log(loglist, 0)

        except:
            githubdata = {}
            self.log([self.text('config', 43), traceback.format_exc()], 0)
            if configuring:
                self.log([self.text('config', 44)], 0)
                return 2

        # Check on disabled sources
        active_sources = get_githubdata("active_sources")
        for c in self.channelsource.keys():
            if c not in active_sources:
                self.validate_option('disable_source', value = c)

        # Remove any source that's not (jet) there
        self.source_order = active_sources[:]
        for s in active_sources:
            if not s in self.channelsource.keys():
                self.source_order.remove(s)

        # Remove any source that's not (jet) there
        self.prime_source_order = get_githubdata("prime_source_order")
        for s in self.prime_source_order[:]:
            if not s in self.channelsource.keys():
                self.prime_source_order.remove(s)

        # Read in the tables needed for normal grabbing
        self.xml_output.logo_provider = {}
        logo_provider = get_githubdict("logo_provider", 1)
        if isinstance(logo_provider, list):
            i=0
            for lp in logo_provider:
                self.xml_output.logo_provider[i] =lp
                i+=1
        else:
            self.xml_output.logo_provider = logo_provider
        combined_channels = get_githubdict("combined_channels_2")
        self.combined_channels = {}
        for chanid, chanlist in combined_channels.items():
            clist = []
            for child in chanlist:
                if isinstance(child, dict) and 'chanid' in child:
                    if 'start' in child:
                        try:
                            st = child['start'].split(':')
                            child['start'] = datetime.time(int(st[0]), int(st[1]), tzinfo=self.combined_channels_tz)
                        except:
                            self.log(self.text('config', 45, (child['chanid'], chanid)))
                            del child['start']

                    if 'end' in child:
                        try:
                            st = child['end'].split(':')
                            child['end'] = datetime.time(int(st[0]), int(st[1]), tzinfo=self.combined_channels_tz)
                        except:
                            self.log(self.text('config', 46, (child['chanid'], chanid)))
                            del child['end']

                    if 'start' in child and not 'end' in child:
                        child['end'] = datetime.time(24, 0, tzinfo=self.combined_channels_tz)

                    elif 'end' in child and not 'start' in child:
                        child['start'] = datetime.time(0, 0, tzinfo=self.combined_channels_tz)

                    clist.append(child)

                elif isinstance(child, (str, unicode)):
                    clist.append({'chanid': child})

            self.combined_channels[chanid] = clist

        self.groupslot_names = get_githubdata("groupslot_names")
        self.ttvdb_aliasses = get_githubdict("ttvdb_aliasses")
        self.generic_channel_genres = get_githubdict("generic_channel_genres")
        self.coutrytrans = get_githubdict("coutrytrans")
        self.prime_source = get_githubdict("prime_source")
        # Remove any source that's not (jet) there
        for c, s in self.prime_source.items():
            if s not in self.channelsource.keys():
                del self.prime_source[c]

        self.notitlesplit = get_githubdata("notitlesplit", self.notitlesplit)
        self.user_agents = get_githubdata("user_agents", self.user_agents)
        #~ self.no_genric_matching = get_githubdict("no_genric_matching", 1)

        # Read the tables only needed during configuring
        self.xml_output.logo_source_preference = get_githubdata("logo_source_preference")
        for k in self.xml_output.logo_provider.keys():
            if k not in self.xml_output.logo_source_preference:
                self.xml_output.logo_source_preference.append(k)

        self.xml_output.logo_names = get_githubdict("logo_names")
        for icon in self.xml_output.logo_names.values():
            if icon[1][-4:] not in ('.png', '.jpg', '.gif'):
                if icon[0] in ('0', '1'):
                    icon[1] = icon[1] + '.gif'

                elif icon[0] in ('2', '6'):
                    icon[1] = icon[1] + '.jpg'

                elif icon[0] in ('3', '4', '5', '7', '8', '10', '11'):
                    icon[1] = icon[1] + '.png'

        self.chan_groups = get_githubdict("channel_groups", 1)
        self.group_order = get_githubdata("group_order")
        for g in self.chan_groups.keys():
            if g not in self.group_order[:]:
                self.group_order.append(g)

        for g in self.group_order:
            if g not in self.chan_groups.keys():
                self.chan_groups[g] = 'Channel groep %s' % g

        self.prime_source_groups = get_githubdict("prime_source_groups", 1)
        # Remove any source that's not (jet) there
        for g, s in self.prime_source_groups.items():
            if s not in self.channelsource.keys():
                del self.prime_source_groups[g]

        self.source_channels = get_githubdict("source_channels", 1)
        #~ self.empty_channels = get_githubdict("empty_channels", 1)
        self.channel_grouping = get_githubdict("channel_grouping", 1)
        self.rtl_channellist = get_githubdict("rtl_channellist")
        self.virtual_channellist = get_githubdict("virtual_channellist")
        self.channel_rename = get_githubdict("channel_rename")
        self.merge_into = get_githubdict("merge_into")
        #~ if configuring:
            #~ self.opt_dict["data_version"] = dv

        logarray = []
        for newch, oldch  in self.merge_into.items():
            newpresent = bool(newch in self.channels)
            newactive = newpresent and self.channels[newch].active
            oldpresent = bool(oldch['chanid'] in self.channels)
            oldactive = oldpresent and self.channels[oldch['chanid']].active
            if configuring:
                if oldpresent:
                    logarray.append(self.text('config', 47, (oldch['chanid'], newch, )))
                    logarray.extend(oldch['message'])
                    # Initiate an alias if the old chanid is active
                    if oldactive and newactive:
                        logarray.append(self.text('config', 48))
                        logarray.append(self.text('config', 49, (oldch['chanid'], )))
                        logarray.append(self.text('config', 50))
                        logarray.append('  xmltvid_alias = %s\n' % oldch['chanid'])
                        logarray.append(self.text('config', 51, (newch, )))

                    elif oldactive and self.channels[newch].opt_dict['xmltvid_alias'] == None:
                        logarray.append(self.text('config', 52))
                        logarray.append('  xmltvid_alias = %s\n' % oldch['chanid'])
                        logarray.append(self.text('config', 53, (newch, )))
                        self.channels[newch].opt_dict['xmltvid_alias'] = oldch['chanid']
                        self.channels[newch].active = True

                    elif oldactive:
                        logarray.append(self.text('config', 54, (newch, )))
                        logarray.append(self.text('config', 55))
                        logarray.append(self.text('config', 56, (oldch['chanid'], )))
                        logarray.append(self.text('config', 57))
                        logarray.append('  xmltvid_alias = %s\n' % self.channels[newch].opt_dict['xmltvid_alias'])
                        logarray.append(self.text('config', 58))
                        logarray.append('  xmltvid_alias = %s\n' % oldch['chanid'])
                        logarray.append(self.text('config', 59, (newch, )))
                        self.channels[newch].active = True

                    self.channels[oldch['chanid']].active = False
                    logarray.append(self.text('config', 60, (oldch['chanid'], )))
                    logarray.append(self.text('config', 61, (newch, )))
                    logarray.append('\n')

                for source, id in oldch['sources'].items():
                    # Link the ids from the old chanid to the new chanid
                    if oldch['chanid'] in self.source_channels[int(source)]:
                        self.source_channels[int(source)][newch] = self.source_channels[int(source)][oldch['chanid']]
                        del self.source_channels[int(source)][oldch['chanid']]

            else:
                if newpresent:
                    # Remove the old one from combined_channels if in there
                    if newch in self.combined_channels.keys():
                        for c in self.combined_channels[newch]:
                            if c['chanid'] == oldch['chanid']:
                                self.combined_channels[newch].remove(c)
                                break

                    # And link the ids to the new chanid
                    for source, id in oldch['sources'].items():
                        self.channels[newch].source_id[int(source)] = id

            self.log(logarray, 0)

    # get_sourcematching_file()

    def get_channels(self):
        """
        Get a list of all available channels and store these
        in a file.
        """
        for channel in self.channels.values():
            # First we clear out all existing source_id's, because they can have become invalid!
            for index in range(self.source_count):
                channel.source_id[index] = ''

            # These groupids have changed, so to be sure
            if self.opt_dict['always_use_json']:
                channel.group = 99

            # And all not custom set icons
            if self.opt_dict['always_use_json'] and channel.icon_source != 99:
                channel.icon_source = -1
                channel.icon = ''

        db_icon = []
        db_channel = []
        db_channel_source = []
        # These channels contain no data!
        source_keys = {}
        reverse_channels = {}
        if not isinstance(self.channels, dict):
            self.channels = {}

        for chanid, icon in self.xml_output.logo_names.items():
            db_icon.append({'sourceid': icon[0], 'chanid': str(chanid),'icon': icon[1]})

        # Get the sources
        for index in (0, 1, 10, 6, 5, 2, 4, 7, 9, 8, 11, 12):
            self.channelsource[index].init_channels()
            if self.channelsource[index].get_channels() == 69:
                self.log(self.text('config',62))
                if not index in self.opt_dict['disable_source']:
                    self.log(self.text('config',63))
                    return 69

            if self.write_info_files:
                #~ self.infofiles.check_new_channels(self.channelsource[index], self.source_channels, self.empty_channels)
                self.infofiles.check_new_channels(self.channelsource[index], self.source_channels)

            # a dict with coresponding source, id and chanid
            reverse_channels[index] = {}
            # a list of all ids for the source
            source_keys[index] = []
            for i, v in self.source_channels[index].items():
                reverse_channels[index][v] = {}
                reverse_channels[index][v]['chanid'] = unicode(i)
                i =i.split('-',1)
                reverse_channels[index][v]['source'] = int(i[0])
                reverse_channels[index][v]['chan_scid'] = unicode(i[1])

            for chan_scid in self.channelsource[index].all_channels.keys():
                #~ if not (chan_scid in self.empty_channels[index]):
                if not (chan_scid in self.channelsource[index].empty_channels):
                    source_keys[index].append(chan_scid)

        for index in (0, 1, 10, 6, 5, 2, 4, 7, 9, 8, 11, 12):
            for chan_scid, channel in self.channelsource[index].all_channels.items():
                if chan_scid in reverse_channels[index].keys():
                    chanid = reverse_channels[index][chan_scid]['chanid']

                else:
                    chanid = '%s-%s' % (index, chan_scid)

                chan ={}
                chan['chanid'] = chanid
                chan['sourceid'] = index
                chan['scid'] = chan_scid
                chan['cgroup'] = channel['group'] if 'group' in channel else 99
                chan['name'] = channel['name']
                if 'HD' in channel:
                    chan['hd'] = channel['HD']

                elif channel['name'][-3:].lower() == ' hd':
                    chan['hd'] = True

                else:
                    chan['hd'] = False

                # These channels are for show, but we like the icons from source 2, 6 and 5!
                #~ if (chan_scid in self.empty_channels[index]):
                if (chan_scid in self.channelsource[index].empty_channels):
                    chan['scid'] = ''
                    chan_scid = ''

                if not chanid in self.channels:
                    #~ if (chan_scid in self.empty_channels[index]):
                    if (chan_scid in self.channelsource[index].empty_channels):
                        continue

                    self.channels[chanid] = tv_grab_fetch.Channel_Config(self, chanid, chan['name'] )

                self.channels[chanid].source_id[index] = chan_scid
                # Set the group
                if ((not self.opt_dict['always_use_json'] and self.channels[chanid].group >= 99)
                    or self.opt_dict['always_use_json']):
                        for g, chan_list in self.channel_grouping.items():
                            if chanid in chan_list:
                                channel['group'] = g
                                break

                if self.channels[chanid].group >= 99:
                    self.channels[chanid].group = channel['group'] if 'group' in channel else 99

                # Move Dutch/Flemish channels from other to main if any sources places them there
                if 'group' in channel and channel['group'] == 1 and self.channels[chanid].group == 7:
                    self.channels[chanid].group = channel['group']

                if 'group' in channel and channel['group'] == 2 and self.channels[chanid].group == 9:
                    self.channels[chanid].group = channel['group']

                # Force Regional radio group
                if 'group' in channel and channel['group'] == 17 and self.channels[chanid].group == 11:
                    self.channels[chanid].group = channel['group']

                # Set the Icon
                icon ={}
                icon['sourceid'] = -1
                icon['chanid'] = chanid
                if 'icon' in channel and channel['icon'] != '':
                    icon['sourceid'] = index if 'icongrp' not in channel else channel['icongrp']
                    icon['icon'] = channel['icon']
                    db_icon.append(icon)

                for iconsource in self.xml_output.logo_source_preference:
                    if self.channels[chanid].icon_source == iconsource:
                        # A higher preference icon is already set
                        break

                    elif chanid in self.xml_output.logo_names.keys() and int(self.xml_output.logo_names[chanid][0]) == iconsource:
                        self.channels[chanid].icon_source = int(self.xml_output.logo_names[chanid][0])
                        self.channels[chanid].icon = self.xml_output.logo_names[chanid][1]
                        break

                    elif icon['sourceid'] == iconsource:
                        self.channels[chanid].icon_source = icon['sourceid']
                        self.channels[chanid].icon = icon['icon']
                        break

                db_channel_source.append(chan)

        for channel in self.channels.values():
            # Some channel title renaming
            if self.opt_dict['always_use_json'] and channel.chanid in self.channel_rename.keys():
                channel.chan_name = self.channel_rename[channel.chanid]

            # mark HD channels
            if channel.chan_name[-3:].lower() == ' hd':
                channel.opt_dict['mark_hd'] = True

            if channel.get_source_id(5) != '' and channel.get_source_id(5) in self.channelsource[5].all_channels \
              and self.channelsource[5].all_channels[channel.get_source_id(5)]['HD']:
                channel.opt_dict['mark_hd'] = True

            # set the default prime_source
            self.validate_option('prime_source', channel, -1)
            if channel.get_source_id(0) in ('3',):
                channel.opt_dict['append_tvgidstv'] = False

            db_channel.append({'name': channel.chan_name,
                                               'chanid': channel.chanid,
                                               'cgroup': channel.group})

        self.program_cache.cache_request.put({'task':'add',
                                               'channel': db_channel,
                                               'channelsource': db_channel_source,
                                               'icon': db_icon})
        return 0

    # end get_channels()

    def write_opts_to_log(self):
        """
        Save the the used options to the logfile
        """
        if self.log_output == None:
            return(0)

        log_array = [u'Python version: %s.%s.%s' % (sys.version_info[0], sys.version_info[1], sys.version_info[2])]
        log_array.append(u"%s: %s" % (self.country, self.version(True)))
        log_array.append(u"The Netherlands: %s" % self.version(True, True))
        log_array.append(u'Capabilities:"baseline" ,"cache" ,"manualconfig" ,"preferredmethod")')
        log_array.append(u'Preferred Methode: "allatonce"')
        log_array.append(u'log level = %s' % (self.opt_dict['log_level']))
        log_array.append(u'match log level = %s' % (self.opt_dict['match_log_level']))
        log_array.append(u'global_timeout = %s' % (self.opt_dict['global_timeout']))
        log_array.append(u'max_simultaneous_fetches = %s' % (self.opt_dict['max_simultaneous_fetches']))
        log_array.append(u'config_file = %s' % (self.opt_dict['config_file']))
        log_array.append(u'cache_file = %s.db' % (self.opt_dict['cache_file']))
        log_array.append(u'clean_cache = %s' % (self.args.clean_cache))
        log_array.append(u'disable_ttvdb = %s' % (self.opt_dict['disable_ttvdb']))
        log_array.append(u'quiet = %s' % (self.opt_dict['quiet']))
        log_array.append(u'output_file = %s' % (self.opt_dict['output_file']))
        log_array.append(u'fast = %s' % (self.opt_dict['fast']))
        log_array.append(u'offset = %s' % (self.opt_dict['offset']))
        log_array.append(u'days = %s' % (self.opt_dict['days']))
        log_array.append(u'slowdays = %s' % (self.opt_dict['slowdays']))
        log_array.append(u'compat = %s' % (self.opt_dict['compat']))
        log_array.append(u'legacy_xmltvids = %s' % (self.opt_dict['legacy_xmltvids']))
        log_array.append(u'max_overlap = %s' % (self.opt_dict['max_overlap']))
        log_array.append(u'overlap_strategy = %s' % (self.opt_dict['overlap_strategy']))
        log_array.append(u'logos = %s' % (self.opt_dict['logos']))
        log_array.append(u'desc_length = %s' % (self.opt_dict['desc_length']))
        log_array.append(u'cattrans = %s' % (self.opt_dict['cattrans']))
        log_array.append(u'use_split_episodes = %s' % (self.opt_dict['use_split_episodes']))
        log_array.append(u'kijkwijzerstijl = %s' % (self.opt_dict['kijkwijzerstijl']))
        log_array.append(u'mark_hd = %s' % (self.opt_dict['mark_hd']))
        log_array.append(u'use_utc = %s' % (self.opt_dict['use_utc']))
        for index in self.source_order:
            if index in self.opt_dict['disable_source']:
                log_array.append(self.text('config', 64, (index, self.channelsource[index].source)))

            elif index in self.opt_dict['disable_detail_source']:
                log_array.append(self.text('config', 65, (index, self.channelsource[index].source)))

        log_array.append(self.text('config', 66))
        for chan_def in self.channels.values():
            if not (chan_def.active or chan_def.is_child):
                continue

            log_array.append(u'[%s (Chanid=%s)]\n' % (chan_def.chan_name, chan_def.chanid))
            if chan_def.opt_dict['xmltvid_alias'] != None:
                log_array.append(u'  xmltvID_alias = %s\n' % (chan_def.opt_dict['xmltvid_alias']))

            src_id = chan_def.opt_dict['prime_source']
            log_array.append(u'  prime_source = %s (%s)\n' % (src_id, self.channelsource[src_id].source))
            #~ log_array.append(u'  prime_source = %s \n' % (src_id))
            if not self.opt_dict['always_use_json'] and chan_def.chanid in self.prime_source and self.prime_source[chan_def.chanid] != src_id:
                log_array.append(self.text('config', 67 ,(self.prime_source[chan_def.chanid], self.channelsource[self.prime_source[chan_def.chanid]].source)))

            for index in chan_def.opt_dict['disable_source']:
                if index in self.opt_dict['disable_source']:
                    continue

                log_array.append(self.text('config', 68, (index, self.channelsource[index].source)))

            for index in chan_def.opt_dict['disable_detail_source']:
                if index in chan_def.opt_dict['disable_source'] or index in self.opt_dict['disable_source'] or index in self.opt_dict['disable_detail_source']:
                    continue

                log_array.append(self.text('config', 69, (index, self.channelsource[index].source)))

            if not chan_def.opt_dict['append_tvgidstv']:
                log_array.append(u'  append_tvgidstv = False\n')

            src_id = chan_def.opt_dict['prefered_description']
            if src_id != -1:
                if chan_def.get_source_id(src_id) != '':
                    log_array.append(u'  prefered_description = %s (%s)\n' % (src_id, self.channelsource[src_id].source))

            if chan_def.opt_dict['add_hd_id']:
                log_array.append(u'  add_hd_id = True\n')

            elif chan_def.opt_dict['mark_hd']:
                log_array.append(u'  mark_hd = True\n')

            if chan_def.opt_dict['slowdays'] != self.opt_dict['slowdays'] and chan_def.opt_dict['slowdays'] != None:
                log_array.append(u'  slowdays = %s' % (chan_def.opt_dict['slowdays']))

            for val in ( 'fast', 'compat', 'legacy_xmltvids', 'max_overlap', 'overlap_strategy', \
              'logos', 'desc_length', 'cattrans', 'disable_ttvdb', 'use_split_episodes'):
                if chan_def.opt_dict[val] != self.opt_dict[val]:
                    log_array.append(u'  %s = %s\n' % (val, chan_def.opt_dict[val]))

        log_array.append(u' \n')
        self.log(log_array, 1, 2)

    # end write_opts_to_log()

    def write_config(self, add_channels = None):
        """
        Save the channel info and the default options
        if add_channels is False or None we copy over the Channels sections, called on save_options
        If add_channels is None we convert the channel info to the new form, called on version update
        if add_channels is True we create a fresh channels section                , called on configure
        """
        self.IO_func.save_oldfile(self.opt_dict['config_file'])
        f = self.IO_func.open_file(self.opt_dict['config_file'], 'w')
        if f == None:
            return False

        f.write(u'# encoding: utf-8\n')
        f.write(u'# configversion: %s.%s%s\n' % (self.api_major + 2, self.api_minor, '{:0>2}'.format(self.api_patch)))
        f.write(u'\n')

        # Save the options
        for i in range(50, 60):
            line = self.text('config', i, type = 'other')
            if line != '':
                f.write(line)

        f.write(u'\n')
        f.write(u'[%s]\n' % self.__CONFIG_SECTIONS__[1])
        f.write(self.text('config', 61, type = 'other'))
        f.write(u'data_version = %s\n' % self.opt_dict['data_version'])
        for i in range(63, 68):
            line = self.text('config', i, type = 'other')
            if line != '':
                f.write(line)

        f.write(u'always_use_json = %s\n' % self.opt_dict['always_use_json'])
        f.write(u'group_active_channels = %s\n' % self.opt_dict['group_active_channels'])
        if self.write_info_files:
            f.write(u'write_info_files = True\n')
            if self.opt_dict['mail_log'] and self.opt_dict['mail_info_address'] != None:
                f.write(u'mail_info_address = %s\n' % self.opt_dict['mail_info_address'])

            f.write(u'\n')

        for i in range(69, 85):
            line = self.text('config', i, type = 'other')
            if line != '':
                f.write(line)

        f.write(u'global_timeout = %s\n' % self.opt_dict['global_timeout'])
        f.write(u'max_simultaneous_fetches = %s\n' % self.opt_dict['max_simultaneous_fetches'])
        f.write(u'\n')
        for i in range(86, 97):
            line = self.text('config', i, type = 'other')
            if line != '':
                f.write(line)

        f.write(u'log_level = %s\n' % self.opt_dict['log_level'])
        for i in range(98, 105):
            line = self.text('config', i, type = 'other')
            if line != '':
                f.write(line)

        f.write(u'match_log_level = %s\n' % self.opt_dict['match_log_level'])
        f.write(u'\n')
        f.write(u'mail_log = %s\n' % self.opt_dict['mail_log'])
        for i in range(106, 112):
            line = self.text('config', i, type = 'other')
            if line != '':
                f.write(line)

        f.write(u'mail_log_address = %s\n' % self.opt_dict['mail_log_address'])
        f.write(u'mailserver = %s\n' % self.opt_dict['mailserver'])
        f.write(u'mailport = %s\n' % self.opt_dict['mailport'])
        f.write(u'\n')
        f.write(u'quiet = %s\n' % self.opt_dict['quiet'])
        f.write(u'output_file = %s\n' % self.opt_dict['output_file'])
        for index in self.source_order:
            if index in self.opt_dict['disable_source']:
                f.write(u'disable_source = %s\n' % index)

            elif index in self.opt_dict['disable_detail_source']:
                f.write(u'disable_detail_source = %s\n' % index)

        f.write(u'disable_ttvdb = %s\n' % self.opt_dict['disable_ttvdb'])
        f.write(u'compat = %s\n' % self.opt_dict['compat'])
        f.write(u'legacy_xmltvids = %s\n' % self.opt_dict['legacy_xmltvids'])
        f.write(u'logos = %s\n' % self.opt_dict['logos'])
        f.write(u'use_utc = %s\n' % self.opt_dict['use_utc'])
        f.write(u'fast = %s\n' % self.opt_dict['fast'])
        f.write(u'offset = %s\n' % self.opt_dict['offset'])
        f.write(u'days = %s\n' % self.opt_dict['days'])
        f.write(u'slowdays = %s\n' % self.opt_dict['slowdays'])
        f.write(u'cattrans = %s\n' % self.opt_dict['cattrans'])
        f.write(u'mark_hd = %s\n' % self.opt_dict['mark_hd'])
        f.write(u'overlap_strategy = %s\n' % self.opt_dict['overlap_strategy'] )
        f.write(u'max_overlap = %s\n' % self.opt_dict['max_overlap'])
        f.write(u'desc_length = %s\n' % self.opt_dict['desc_length'])
        for i in range(113, 119):
            line = self.text('config', i, type = 'other')
            if line != '':
                f.write(line)

        f.write(u'kijkwijzerstijl = %s\n' % self.opt_dict['kijkwijzerstijl'])
        f.write(u'use_split_episodes = %s\n' % self.opt_dict['use_split_episodes'])
        f.write(u'\n')
        for i in range(120, 163):
            line = self.text('config', i, type = 'other')
            if line != '':
                f.write(line)

        def get_channel_string(chanid, active = None, chan_string = None, icon_string = None):
            chan = self.channels[chanid]
            for index in range(self.source_count):
                if chan.get_source_id(index) != '':
                    break

            else:
                # There are no Source ids so we remove it
                return {'chan_string': None, 'active': None}

            if active == None:
                active = chan.active

            if chan_string == None:
                chan_string = '%s;%s;%s' % (chan.chan_name, chan.group, chanid)

            for index in range(self.source_count):
                chan_string = '%s;%s' % (chan_string, chan.get_source_id(index))

            if icon_string == None:
                chan_string = '%s;%s;%s\n' % (chan_string, chan.icon_source, chan.icon)

            else:
                chan_string = '%s;%s\n' % (chan_string, icon_string)

            if active:
                return {'chan_string': chan_string, 'active': active}

            else:
                return {'chan_string': '# %s' % chan_string, 'active': active}

        # just copy over the channels section
        if add_channels == False and self.configversion == float('%s.%s' % (self.api_major+2, self.api_minor)):
            fo = self.IO_func.open_file(self.opt_dict['config_file'] + '.old')
            if fo == None or not self.IO_func.check_encoding(fo):
                # We cannot read the old config, so we create a new one
                self.log(self.text('config', 70))
                add_channels = True

            else:
                self.encoding = self.IO_func.encoding
                fo.seek(0,0)
                type = 0
                for byteline in fo.readlines():
                    line = self.IO_func.get_line(fo, byteline, None)
                    try:
                        if  line == False:
                            continue

                        # Look for section headers
                        config_title = re.search('\[(.*?)\]', line)
                        if config_title != None and (config_title.group(1) in self.__CONFIG_SECTIONS__.values()):
                            for i, v in self.__CONFIG_SECTIONS__.items():
                                if v == config_title.group(1):
                                    type = i
                                    break

                        elif config_title != None and (config_title.group(1)[0:8] == 'Channel '):
                            type = 9

                        # Unknown Section header, so ignore
                        if line[0:1] == '[':
                            type = 0
                            continue

                        if type > 1:
                            # We just copy everything except the old configuration (type = 1)
                            f.write(line + u'\n')
                    except:
                        self.log(self.text('config', 71))
                        continue

                fo.close()
                f.close()
                return True

        # This is an upgrade
        chan_not_updated = []
        if add_channels != True:
            configlines = {}
            configlines['2remarks'] = []
            configlines['2'] = []
            configlines['3remarks'] = []
            configlines['3'] = []
            configlines['9'] = {}
            # Get the old channels section to convert
            fo = self.IO_func.open_file(self.opt_dict['config_file'] + '.old')
            if fo == None or not self.IO_func.check_encoding(fo, None, True):
                # We cannot read the old config, so we create a new one
                self.log(self.text('config', 70))
                self.get_channels()
                add_channels = True

            else:
                self.encoding = self.IO_func.encoding
                self.configversion = self.IO_func.configversion
                fo.seek(0,0)
                if self.configversion == 1.0:
                    type = 2

                else:
                    type = 0

                # Read the old configuration
                for byteline in fo.readlines():
                    line = self.IO_func.get_line(fo, byteline, None, self.encoding)
                    try:
                        if line == '# encoding: utf-8' or line[0:17] == '# configversion: ' or line == False or line == '':
                            continue

                        if self.configversion != 1.0:
                            # Look for section headers
                            config_title = re.search('\[(.*?)\]', line)
                            if config_title != None and (config_title.group(1) in self.__CONFIG_SECTIONS__.values()):
                                section = config_title.group(1)
                                for i, v in self.__CONFIG_SECTIONS__.items():
                                    if v == config_title.group(1):
                                        type = i
                                        continue

                                continue

                            elif config_title != None and (config_title.group(1)[0:8] == 'Channel '):
                                section = config_title.group(1)
                                type = 9
                                chanid = config_title.group(1)[7:].strip()
                                configlines['9'][chanid] = []
                                continue

                            # Unknown Section header, so ignore
                            if line[0:1] == '[' or re.sub('#', '', line).strip() == u'Channel specific settings other then the above or the default:':
                                type = 0
                                continue

                        if type == 2 and self.configversion <= 2.0:
                            if line[0:1] == '#':
                                configlines['2remarks'].append(line)

                            else:
                                configlines['2'].append(line)

                        elif type == 3 and self.configversion > 2.0:
                            if line[0:1] == '#':
                                configlines['3remarks'].append(line)

                            else:
                                configlines['3'].append(line)

                        elif type == 9 and self.configversion > 2.0:
                            configlines['9'][chanid].append(line)

                    except:
                        self.log(self.text('config', 71))
                        continue

                fo.close()

                self.get_channels()
                chan_added = []
                chan_list = {}
                for g in self.group_order:
                    chan_list[unicode(g)] =[]

                if self.configversion <= 2.0:
                    for item in configlines['2']:
                        chan = item.split(None, 1) # split on first whitespace
                        if len(chan) != 2:
                            chan_not_updated.append(u'# %s\n' % (item))
                            continue

                        if chan[0].strip() in self.channels.keys():
                            chanid = chan[0].strip()
                            grp = u'0' if self.args.group_active_channels else unicode(self.channels[chanid].group)
                            chan_list[grp].append(get_channel_string(chanid, True, '%s;%s;%s' % \
                                (chan[1], self.channels[chanid].group, chanid)))
                            chan_added.append(chanid)

                        else:
                            chan_not_updated.append(u'# %s\n' % (item))

                    for item in configlines['2remarks']:
                        chan = re.sub('#', '', item)
                        chan = chan.split(None, 1) # split on first whitespace
                        if len(chan) != 2:
                            chan_not_updated.append(u'# %s\n' % (item))
                            continue

                        if chan[0].strip() in self.channels.keys():
                            chanid = chan[0].strip()
                            chan_list[unicode(self.channels[chanid].group)].append(get_channel_string(chanid, False, '%s;%s;%s' % \
                                (chan[1], self.channels[chanid].group, chanid)))
                            chan_added.append(chanid)

                        else:
                            chan_not_updated.append(u'# %s\n' % (item))

                if self.configversion > 2.0:
                    for item in configlines['3']:
                        chan = re.split(';', item)
                        if self.configversion == 2.1 and len(chan) != 8:
                            chan_not_updated.append(u'# %s\n' % (item))
                            continue

                        chan_found = False
                        for chanid, channel in self.channels.items():
                            for index in range(min(self.source_count,len(chan) - 4)):
                                if (chan[index + 2].strip() !='') and (chan[index + 2].strip() == channel.get_source_id(index)):
                                    chan_found = True
                                    grp = u'0' if self.args.group_active_channels else chan[1]
                                    chan_list[grp].append(get_channel_string(chanid, True, '%s;%s;%s' % \
                                        (chan[0], chan[1], chanid), '%s;%s' % (chan[-2], chan[-1])))
                                    chan_added.append(chanid)
                                    chan_found = True
                                    break

                            if chan_found:
                                break

                        else:
                            chan_not_updated.append(u'# %s\n' % (item))

                    for item in configlines['3remarks']:
                        chan = re.sub('#', '', item)
                        if chan.strip() in self.group_order:
                            continue

                        chan = re.split(';', chan)
                        if self.configversion == 2.1 and len(chan) != 8:
                            chan_not_updated.append(u'# %s\n' % (item))
                            continue

                        chan_found = False
                        for chanid, channel in self.channels.items():
                            for index in range(min(self.source_count,len(chan) - 4)):
                                if (chan[index + 2].strip() !='') and (chan[index + 2].strip() == channel.get_source_id(index)):
                                    chan_list[chan[1]].append(get_channel_string(chanid, False, '%s;%s;%s' % \
                                        (chan[0], chan[1], chanid), '%s;%s' % (chan[-2], chan[-1])))
                                    chan_added.append(chanid)
                                    chan_found = True
                                    break

                            if chan_found:
                                break

                        else:
                            chan_not_updated.append(u'# %s\n' % (item))

                del configlines['2']
                del configlines['3']
                del configlines['2remarks']
                del configlines['3remarks']
                for chanid, channel in self.channels.items():
                    if not chanid in chan_added:
                        chan_list[unicode(channel.group)].append(get_channel_string(chanid, False))

                # At a later config upgrade we here have to parse the type 9 sections

        if add_channels:
            chan_list = {}
            for g in self.group_order:
                chan_list[unicode(g)] =[]

            for chanid, channel in self.channels.items():
                grp = u'0' if self.args.group_active_channels and channel.active else unicode(channel.group)
                chan_list[grp].append(get_channel_string(chanid))

        f.write(u'[%s]\n' % self.__CONFIG_SECTIONS__[3])
        for g in self.group_order:
            if g == 0 and not self.opt_dict['group_active_channels']:
                continue

            f.write(u'\n')
            f.write(u'# %s\n' % self.chan_groups[g])
            chan_list[unicode(g)].sort(key=lambda channel: (channel['chan_string']))
            chan_list[unicode(g)].sort(key=lambda channel: (channel['active']), reverse=True)
            for channel in chan_list[unicode(g)]:
                if channel['chan_string'] != None:
                    f.write(channel['chan_string'])

        if len(chan_not_updated) > 0:
            f.write(u'\n')
            f.write(u'# Following are not converted lines!\n')
            for line in chan_not_updated:
                f.write(line)

        f.write(u'\n')
        f.write(u'# Channel specific settings other then the above or the default:\n')
        chan_names = []
        for chan_def in self.channels.values():
            for index in range(self.source_count):
                if chan_def.get_source_id(index) != '':
                    # Only add specific settings if at least one sourceid present
                    chan_names.append({'active': chan_def.active, 'name': chan_def.chan_name, 'id': chan_def.chanid})
                    break

        chan_names.sort(key=lambda channel: (channel['name']))
        chan_names.sort(key=lambda channel: (channel['active']), reverse=True)

        for chan in chan_names:
            chan_def = self.channels[chan['id']]
            chan_name_written = False
            for index in chan_def.opt_dict['disable_source']:
                if index in self.opt_dict['disable_source']:
                    continue

                if index in chan_def.source_id.keys() and chan_def.get_source_id(index) != '':
                    if not chan_name_written:
                        f.write(u'\n')
                        f.write(u'# %s\n' % (chan_def.chan_name))
                        f.write(u'[Channel %s]\n' % (chan_def.chanid))
                        chan_name_written = True

                    f.write(u'disable_source = %s\n' % index)

            for index in chan_def.opt_dict['disable_detail_source']:
                if index in chan_def.opt_dict['disable_source'] or index in self.opt_dict['disable_source'] or index in self.opt_dict['disable_detail_source']:
                    continue

                if index in chan_def.source_id.keys() and chan_def.get_source_id(index) != '':
                    if not chan_name_written:
                        f.write(u'\n')
                        f.write(u'# %s\n' % (chan_def.chan_name))
                        f.write(u'[Channel %s]\n' % (chan_def.chanid))
                        chan_name_written = True

                    f.write(u'disable_detail_source = %s\n' % index)

            if not chan_def.opt_dict['append_tvgidstv']:
                if not chan_name_written:
                    f.write(u'\n')
                    f.write(u'# %s\n' % (chan_def.chan_name))
                    f.write(u'[Channel %s]\n' % (chan_def.chanid))
                    chan_name_written = True

                f.write(u'append_tvgidstv = False\n')

            if chan_def.opt_dict['xmltvid_alias'] != None and chan_def.opt_dict['xmltvid_alias'] != chan_def.chanid:
                if not chan_name_written:
                    f.write(u'\n')
                    f.write(u'# %s\n' % (chan_def.chan_name))
                    f.write(u'[Channel %s]\n' % (chan_def.chanid))
                    chan_name_written = True

                f.write(u'xmltvid_alias = %s\n' % (chan_def.opt_dict['xmltvid_alias']))

            if not self.validate_option('prime_source', chan_def, check_default = True):
                if not chan_name_written:
                    f.write(u'\n')
                    f.write(u'# %s\n' % (chan_def.chan_name))
                    f.write(u'[Channel %s]\n' % (chan_def.chanid))
                    chan_name_written = True

                f.write(u'prime_source = %s\n' % chan_def.opt_dict['prime_source'])

            opt_val = chan_def.opt_dict['prefered_description']
            if opt_val in chan_def.source_id.keys() and chan_def.get_source_id(opt_val) != '':
                if not chan_name_written:
                    f.write(u'\n')
                    f.write(u'# %s\n' % (chan_def.chan_name))
                    f.write(u'[Channel %s]\n' % (chan_def.chanid))
                    chan_name_written = True

                f.write(u'prefered_description = %s\n' % ( opt_val))

            if chan_def.opt_dict['add_hd_id']:
                if not chan_name_written:
                    f.write(u'\n')
                    f.write(u'# %s\n' % (chan_def.chan_name))
                    f.write(u'[Channel %s]\n' % (chan_def.chanid))
                    chan_name_written = True

                f.write(u'add_hd_id = True\n')

            if chan_def.opt_dict['slowdays'] != self.opt_dict['slowdays'] and chan_def.opt_dict['slowdays'] != None:
                if not chan_name_written:
                    f.write(u'\n')
                    f.write(u'# %s\n' % (chan_def.chan_name))
                    f.write(u'[Channel %s]\n' % (chan_def.chanid))
                    chan_name_written = True

                f.write(u'slowdays = %s\n' % (chan_def.opt_dict['slowdays']))

            if self.opt_dict['disable_ttvdb'] == False and chan_def.opt_dict['disable_ttvdb'] == True:
                if not chan_name_written:
                    f.write(u'\n')
                    f.write(u'# %s\n' % (chan_def.chan_name))
                    f.write(u'[Channel %s]\n' % (chan_def.chanid))
                    chan_name_written = True

                f.write(u'disable_ttvdb = True\n')

            for val in ( 'fast', 'compat', 'legacy_xmltvids', 'max_overlap', 'overlap_strategy', \
              'logos', 'desc_length', 'cattrans', 'mark_hd', 'use_split_episodes'):
                if chan_def.opt_dict[val] != self.opt_dict[val]:
                    if not chan_name_written:
                        f.write(u'\n')
                        f.write(u'# %s\n' % (chan_def.chan_name))
                        f.write(u'[Channel %s]\n' % (chan_def.chanid))
                        chan_name_written = True

                    f.write(u'%s = %s\n' % (val, chan_def.opt_dict[val]))

        f.close()
        return True
    # end write_config()

    def write_defaults_list(self):
        """
        Save the genre conversion table, the title split exception list and othe translation tables
        """
        self.IO_func.save_oldfile(self.opt_dict['settings_file'])
        f = self.IO_func.open_file(self.opt_dict['settings_file'], 'w')
        if f == None:
            return False

        f.write(u'# encoding: utf-8\n')
        f.write(u'\n')
        f.write(u'# This is a list of the role-titles encountered\n')
        f.write(u'# with a translation to the english titles as used in MythTV.\n')
        f.write(u'\n')
        f.write(u'[%s]\n' % self.__DEFAULT_SECTIONS__[7])

        l = []
        for i, t in self.roletrans.iteritems():
            l.append(u'%s = %s\n' % (i,t))
        l.sort()
        for string in l:
            f.write(string)

        f.write(u'\n')
        f.write(u'# This is a list of titles containing a \':\' not to split\n')
        f.write(u'# in a title and a subtitle\n')
        f.write(u'# These will mainly be spin-off series like \'NCIS: Los Angeles\'\n')
        f.write(u'# Movies and programs already having a subtitle are already excluded.\n')
        f.write(u'\n')
        f.write(u'[%s]\n' % self.__DEFAULT_SECTIONS__[2])

        self.notitlesplit.sort()
        for t in self.notitlesplit:
             f.write(u'%s\n' % t)

        f.write(u'\n')
        f.write(u'# This is a list of grouptitles in titles containing a \':\'\n')
        f.write(u'# to remove from the title\n')
        f.write(u'# For instance \"KRO detectives\".\n')
        f.write(u'# This among others to cover diferent naming on separate sources.\n')
        f.write(u'\n')
        f.write(u'[%s]\n' % self.__DEFAULT_SECTIONS__[3])

        self.groupnameremove.sort()
        for t in self.groupnameremove:
             f.write(u'%s\n' % t)

        f.write(u'\n')
        f.write(u'# This is a list of titles to rename.\n')
        f.write(u'# For instance \"navy NCIS\" to \"NCIS\".\n')
        f.write(u'# This among others to cover diferent naming on separate sources.\n')
        f.write(u'\n')
        f.write(u'[%s]\n' % self.__DEFAULT_SECTIONS__[4])

        l = []
        for i, t in self.titlerename.iteritems():
            l.append(u'%s = %s\n' % (i,t))
        l.sort()
        for string in l:
            f.write(string)

        f.write(u'\n')
        f.write(u'# These are the translation lists for npo.nl, horizon.tv, humo.be, vpro.nl,\n')
        f.write(u'# primo.eu and vrt.be genres to tvgids.nl genre:subgenre. If you have cattrans\n')
        f.write(u'# enabled, they will next be converted according to the list further down.\n')
        f.write(u"# Notice you don't see any Movie category in the horizon list. This is ruled by\n")
        f.write(u'# a separate flag\n')
        for index in (4, 5, 6, 7, 9, 10):
            f.write(u'\n')
            f.write(u'[%s]\n' % self.__DEFAULT_SECTIONS__[index+4])

            # remove doubles and sort
            for k in self.new_cattrans[index].keys():
                if not (k in self.source_cattrans[index].keys()):
                    self.source_cattrans[index][k] = self.new_cattrans[index][k]

            # format for export
            gl1 = []
            gl = []
            for k, (v1, v2) in self.source_cattrans[index].iteritems():
                if isinstance(k, (str, unicode)):
                    gl1.append(u'%s = %s: %s\n' % (k, v1, v2))

                elif isinstance(k, (list, tuple)) and len(k) == 1:
                    gl1.append(u'%s: = %s: %s\n' % (k[0], v1, v2))

                elif isinstance(k, (list, tuple)) and len(k) == 2 and k[1] != '':
                    gl.append(u'%s: %s = %s: %s\n' % (k[0], k[1], v1, v2))

            gl1.sort()
            for string in gl1:
                f.write(string)

            gl.sort()
            for string in gl:
                f.write(string)

        f.write(u'\n')
        f.write(u'# This is the list of genres to add the tvgidstv genres as subgenre\n')
        f.write(u'# tvgids.tv genres are like tvgids.nl subgenres. This is a list of what\n')
        f.write(u'# genre to add to a subgenre. Available genres are:\n')
        f.write(u'#   Amusement             Magazine                Serie/Soap\n')
        f.write(u'#   Film                  Muziek                  Sport\n')
        f.write(u'#   Informatief           Natuur                  Wetenschap\n')
        f.write(u'#   Jeugd                 Nieuws/Actualiteiten    Overige\n')
        f.write(u'#   Kunst en Cultuur      Religieus\n')
        f.write(u'# New found "subgenres" are automatically added and matched on generic rules\n')
        f.write(u'\n')
        f.write(u'[%s]\n' % self.__DEFAULT_SECTIONS__[6])

        # remove doubles and sort
        gs = set(self.new_cattrans[1])
        gl = []
        for k, v in gs:
            if not (k in self.source_cattrans[1]):
                self.source_cattrans[1][k] = v

        # format for export
        for k, v in self.source_cattrans[1].iteritems():
            gl.append(u'%s = %s\n' % (v, k))
        gl.sort()

        for string in gl:
            f.write(string)

        f.write(u'\n')
        f.write(u'# This is the \'Genre:Subgenre\' conversion table\n')
        f.write(u'# \n')
        f.write(u'# \'Genre:Subgenre\' will automatically be converted to lowercase\n')
        f.write(u'# and leading and following spaces will be removed\n')
        f.write(u'# It will automatically get sorted with the genres without\n')
        f.write(u'# a subgenre at the top.\n')
        f.write(u'# Also new found values will be added on every new scan\n')
        f.write(u'# \n')
        f.write(u'# Behind the \'=\' you can supply the category to be used\n')
        f.write(u'# If a category value is empty the main category or an existing\n')
        f.write(u'# default will be used\n')
        f.write(u'# If a main category is empty the default will be supplied\n')
        f.write(u'# and used. If no default exists \'Unknown\' will be used.\n')
        f.write(u'# You should regualary check on new main categories\n')
        f.write(u'# so they don\'t get translated to \'Unknown\'\n')
        f.write(u'\n')
        f.write(u'[%s]\n' % self.__DEFAULT_SECTIONS__[1])

        l1 = []
        l2 = []

        # remove doubles
        gs = set(self.genre_list)
        # add them to cattrans if not yet known
        for i in gs:
            if not (i in self.cattrans):
                self.cattrans[i]=''

        # format for export and add main genres and sub-genres to seperate lists to get sorted
        # add missing maingenres for new subgenres
        for k1, k2 in self.cattrans:
            if k2 == '':
                l1.append(u'%s: = %s\n' % (k1, self.cattrans[(k1,k2)]))
            else:
                l2.append(u'%s: %s = %s\n' % (k1, k2, self.cattrans[(k1,k2)]))
                i = (k1, u'')
                if not (i in self.cattrans):
                    l1.append(u'%s:=\n' % k1)
        l1.sort()
        l2.sort()

        for string in l1:
            f.write(string)

        f.write(u'\n')
        for string in l2:
            f.write(string)

        f.close()
    # end write_defaults_list()

    def write_statistics(self, start, end):
        log_array = ['\n', self.text('config', 72), '\n']
        log_array.append(self.text('config', 73, (self.xml_output.program_count, self.chan_count)))
        log_array.append(self.text('config', 74, (start.strftime('%Y-%m-%d %H:%M'), )))
        log_array.append(self.text('config', 75, (end.strftime('%Y-%m-%d %H:%M'), )))
        log_array.append(self.text('config', 76, (end - start, )))
        fetch_count = self.fetch_func.get_counter('base', 'total') + self.fetch_func.get_counter('detail', 'total')
        log_array.append( self.text('config', 77, (fetch_count, self.fetch_func.get_counter('fail', 'total'))))
        log_array.append(self.text('config', 78, (self.fetch_func.get_counter('detail', -1), )))
        log_array.append(self.text('config', 79, (self.fetch_func.get_counter('lookup', -2), )))
        log_array.append(self.text('config', 80, (self.fetch_func.get_counter('lookup_fail', -2), )))
        if fetch_count > 0:
            log_array.extend([self.text('config', 81, ((end - start).total_seconds()/fetch_count, )), '\n'])
        log_array.append(self.text('config', 82, (self.fetch_func.get_counter('detail', -2), )))
        log_array.extend([self.text('config', 83, (self.fetch_func.get_counter('fail', -2), )), '\n'])
        for s, source in self.channelsource.items():
            log_array.append(self.text('config', 84, (self.fetch_func.get_counter('base', s), source.source)))
            if source.detail_processor:
                log_array.append(self.text('config', 85, (self.fetch_func.get_counter('detail', s), source.source)))

            log_array.extend([self.text('config', 86, (self.fetch_func.get_counter('fail', s), source.source)), '\n'])

        self.log(log_array, 4, 3)
    # write_statistics()

    def close(self):
        try:
            if self.infofiles != None:
                self.infofiles.close(self.channels, self.combined_channels, self.channelsource)

        except:
            self.logging.log_queue.put({'fatal': [traceback.format_exc(), '\n'], 'name': 'InfoFiles'})
            self.ready = True

        if self.program_cache != None and self.program_cache.is_alive():
            self.program_cache.cache_request.put({'task':'quit'})
            self.program_cache = None

        if self.ttvdb != None and self.ttvdb.is_alive():
            self.ttvdb.detail_request.put({'task':'quit'})
            self.ttvdb = None

        # close everything neatly
        if self.opt_dict['output_file'] != None:
            try:
                self.output.close()

            except:
                pass

        self.logging.log_queue.put('Closing down\n')
        if self.logging.is_alive():
            self.logging.join()

        if self.log_output != None:
            self.log_output.close()

    # end close()

# end Configure()
